# KnockOff Interceptor API Reference

This document provides a complete API reference for all interceptor types generated by KnockOff. Interceptors track calls, manage state, and configure callback behavior for stub members.

---

## Overview

KnockOff generates five types of interceptors, each exposed through properties named after the interface:

| Interceptor Type | Generated For | Container Property |
|-----------------|---------------|-------------------|
| **Method Interceptor** | Interface methods (non-generic) | `{Interface}.{MethodName}` |
| **Generic Method Interceptor** | Generic interface methods | `{Interface}.{MethodName}` |
| **Property Interceptor** | Interface properties | `{Interface}.{PropertyName}` |
| **Indexer Interceptor** | Interface indexers | `{Interface}.Indexer` |
| **Event Interceptor** | Interface events | `{Interface}.{EventName}` |

All interceptors provide a `Reset()` method to clear tracking state and callbacks.

### Quick Reference Example

<!-- snippet: interceptor-overview-quick-example -->
```cs
// Method interceptor
stub.Save.OnCall((item) => { }).Verifiable();

// Generic method interceptor
stub.GetById.Of<User>().OnCall((id) => new User { Id = id });

// Property interceptor
stub.Name.OnGet("TestRepo");

// Indexer interceptor
stub.Indexer.Backing["key1"] = new User { Id = 1 };

// Event interceptor
repo.Changed += (s, e) => { };
stub.Changed.VerifyAdd();
```
<!-- endSnippet -->

### Accessing Interceptors Across Usage Patterns

The interceptor API works identically across all three KnockOff usage patterns:

**Standalone Pattern** - `[KnockOff]` on a class implementing an interface:

<!-- snippet: api-access-standalone-pattern -->
```cs
// Standalone: [KnockOff] on class implementing IUserRepo
var stub = new ApiUserRepoStub();

// Interceptor accessed via interface-named property
stub.GetById.OnCall((id) => new User { Id = id });
stub.Save.OnCall((user) => { }).Verifiable();

IApiUserRepo repository = stub;
repository.Save(new User { Id = 1 });

stub.Verify();
```
<!-- endSnippet -->

**Inline Interface Pattern** - `[KnockOff<IFoo>]` generating a stub class:

<!-- snippet: api-access-inline-interface-pattern -->
```cs
// Inline Interface: [KnockOff<IApiUserRepo>] generates Stubs.IApiUserRepo
var stub = new Stubs.IApiUserRepo();

// Same interceptor API as standalone
stub.GetById.OnCall((id) => new User { Id = id });
stub.Save.OnCall((user) => { }).Verifiable();

IApiUserRepo repository = stub;
repository.Save(new User { Id = 1 });

stub.Verify();
```
<!-- endSnippet -->

**Inline Class Pattern** - `[KnockOff<SomeClass>]` generating a stub class:

<!-- snippet: api-access-inline-class-pattern -->
```cs
// Inline Class: [KnockOff<ApiServiceClass>] generates Stubs.ApiServiceClass
var stub = new Stubs.ApiServiceClass();

// Interceptors accessed via class-named container
stub.GetUser.OnCall((id) => new User { Id = id, Name = "FromStub" });
stub.SaveUser.OnCall((user) => { }).Verifiable();

// Use .Object to get the actual class instance
ApiServiceClass service = stub.Object;
var user = service.GetUser(1);
service.SaveUser(user!);

stub.Verify();
```
<!-- endSnippet -->

**Key Insight**: The container property is always named after the interface or class being stubbed. The member interceptors within use the member's declared name.

---

## Method Interceptor

Generated for non-generic interface methods. Tracks call counts, captures arguments, and supports callback configuration.

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `OnCall` | Method | Configures callback/return value. Returns `IMethodTracking<T>` for accessing `LastArg` |

### Tracking Properties

The `OnCall` method returns `IMethodTracking<T>` (or `IMethodTrackingArgs<TArgs>` for multi-parameter methods) which provides:

| Property | Type | Description |
|----------|------|-------------|
| `LastArg` | `T` | The argument from the most recent call (single-parameter methods only) |
| `LastArgs` | `(T1, T2, ...)` | Tuple of arguments from the most recent call (multi-parameter methods) |

**Note**: Parameterless methods return a tracking interface with `Verifiable()` but no argument capture properties.

### Verification Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `Verify()` | `void` | Verify method was called at least once (throws if not) |
| `Verify(Times)` | `void` | Verify method was called according to Times constraint |
| `Verifiable()` | `{Interceptor}` | Mark interceptor for batch verification with default constraint (AtLeastOnce), returns self for chaining |
| `Verifiable(Times)` | `{Interceptor}` | Mark interceptor for batch verification with specific Times constraint, returns self for chaining |

**Note**: `Verifiable()` and `Verifiable(Times)` return the interceptor instance, enabling fluent chaining with `OnCall`.

### OnCall Signatures

The `OnCall` property type varies based on method signature:

| Method Signature | OnCall Type |
|-----------------|-------------|
| `void M()` | `Action` |
| `void M(T arg)` | `Action<T>` |
| `void M(T1 a, T2 b)` | `Action<T1, T2>` |
| `R M()` | `Func<R>` |
| `R M(T arg)` | `Func<T, R>` |
| `R M(T1 a, T2 b)` | `Func<T1, T2, R>` |

When `OnCall` is set, the callback is invoked instead of user-defined methods. For `Func<>` callbacks, the return value is used as the method result.

### Methods

- `void Reset()` - Clears tracking state, `LastCallArg`, `LastCallArgs`, and `OnCall`

### Example

<!-- snippet: method-interceptor-complete-api-demo -->
```cs
// Configure void method with OnCall and mark verifiable
stub.Save.OnCall((user) => { }).Verifiable();

// Configure return method with OnCall
var getTracking = stub.GetById.OnCall((id) =>
    new User { Id = id, Name = $"User{id}" }).Verifiable();

// Configure multi-parameter method
var updateTracking = stub.Update.OnCall((id, name) => { }).Verifiable();

// Exercise the stub
repository.Save(new User { Id = 1, Name = "Alice" });
var user = repository.GetById(42);
repository.Update(1, "UpdatedName");

// Batch verify all Verifiable() interceptors
stub.Verify();

// Tracking object's LastArg for single-parameter methods
Assert.Equal(42, getTracking.LastArg);

// Tracking object's LastArgs tuple for multi-parameter methods
var (id, name) = updateTracking.LastArgs;
Assert.Equal(1, id);
Assert.Equal("UpdatedName", name);
```
<!-- endSnippet -->

---

## Property Interceptor

Generated for interface properties. Tracks get/set operations and supports get/set callbacks.

### Configuration Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `OnGet(Func<T>)` | `IPropertyGetTracking` | Configures getter callback that repeats indefinitely |
| `OnGet(T)` | `IPropertyGetTracking` | Configures getter to return specified value (convenience overload) |
| `OnSet(Action<T>)` | `IPropertySetTracking<T>` | Configures setter callback that repeats indefinitely |

### Tracking Properties

| Property | Type | Description |
|----------|------|-------------|
| `LastSetValue` | `T?` | The value from the most recent setter call |

### Verification Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `VerifyGet()` | `void` | Verify property getter was called at least once (throws if not) |
| `VerifyGet(Times)` | `void` | Verify property getter was called according to Times constraint |
| `VerifySet()` | `void` | Verify property setter was called at least once (throws if not) |
| `VerifySet(Times)` | `void` | Verify property setter was called according to Times constraint |
| `Verifiable()` | `{Interceptor}` | Mark property for batch verification with default constraint (AtLeastOnce), returns self for chaining |
| `Verifiable(Times)` | `{Interceptor}` | Mark property for batch verification with specific Times constraint, returns self for chaining |

### Behavior Notes

- **OnGet value overload**: For convenience, `OnGet(value)` is equivalent to `OnGet(() => value)`
- **OnSet does not auto-update getter**: Setting `OnSet` does NOT automatically update what the getter returns. If you need the getter to reflect set values, configure the callback to update OnGet
- **Init-only properties**: Setters for `init` properties are tracked like regular setters

### Methods

- `void Reset()` - Clears tracking state, `LastSetValue`, and callbacks

### Example

<!-- snippet: property-interceptor-complete-api-demo -->
```cs
// Value: Direct value for getter
stub.ConnectionString.OnGet("Server=localhost");

// OnGet callback: Dynamic value
stub.Timeout.OnGet(() => 30);

// Exercise getter
var conn = repository.ConnectionString;
var timeout = repository.Timeout;

// VerifyGet: Check read count
stub.ConnectionString.VerifyGet(Times.Once);
stub.Timeout.VerifyGet(Times.Once);

// Exercise setter
repository.ConnectionString = "Server=production";
repository.Timeout = 60;

// VerifySet: Check write count
stub.ConnectionString.VerifySet(Times.Once);

// LastSetValue: Captured value from setter
Assert.Equal("Server=production", stub.ConnectionString.LastSetValue);

// IMPORTANT: OnSet does NOT auto-update getter value
var setWasCalled = false;
stub.Timeout.OnSet((val) =>
{
    setWasCalled = true;
    // To update getter: stub.Timeout.OnGet(val);
});
repository.Timeout = 90;
Assert.True(setWasCalled);
// Getter still returns 30 - OnSet didn't change it
```
<!-- endSnippet -->

---

## Indexer Interceptor

Generated for interface indexers. Maintains a backing dictionary, tracks get/set operations, and supports indexed callbacks.

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `Backing` | `Dictionary<TKey, TValue>` | Backing dictionary used by default get/set operations |
| `LastGetKey` | `TKey?` | The key from the most recent getter call |
| `LastSetEntry` | `(TKey, TValue)?` | Tuple of key and value from the most recent setter call |

### Configuration Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `OnGet(Func<TKey, TValue>)` | `IIndexerGetTracking<TKey>` | Configures getter callback that repeats indefinitely |
| `OnSet(Action<TKey, TValue>)` | `IIndexerSetTracking<TKey, TValue>` | Configures setter callback that repeats indefinitely |

### Verification Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `VerifyGet()` | `void` | Verify indexer getter was called at least once (throws if not) |
| `VerifyGet(Times)` | `void` | Verify indexer getter was called according to Times constraint |
| `VerifySet()` | `void` | Verify indexer setter was called at least once (throws if not) |
| `VerifySet(Times)` | `void` | Verify indexer setter was called according to Times constraint |
| `Verifiable()` | `{Interceptor}` | Mark indexer for batch verification with default constraint (AtLeastOnce), returns self for chaining |
| `Verifiable(Times)` | `{Interceptor}` | Mark indexer for batch verification with specific Times constraint, returns self for chaining |

### Behavior Notes

- **Backing dictionary**: By default, get returns `Backing[key]` and set stores to `Backing[key]`
- **OnGet override**: When `OnGet` is set, the callback's return value is used instead of `Backing`
- **OnSet override**: When `OnSet` is set, the callback is invoked. `Backing` is NOT updated automatically unless your callback does it

### Methods

- `void Reset()` - Clears tracking state, `LastGetKey`, `LastSetEntry`, `OnGet`, and `OnSet`. Does NOT clear `Backing`

### Example

<!-- snippet: indexer-interceptor-complete-api-demo -->
```cs
// Backing dictionary: Default storage for indexer
stub.Indexer.Backing[1] = new User { Id = 1, Name = "Alice" };
stub.Indexer.Backing[2] = new User { Id = 2, Name = "Bob" };

// Read uses Backing by default
var user1 = repository[1];
Assert.Equal("Alice", user1?.Name);

// VerifyGet: Check read count
stub.Indexer.VerifyGet(Times.Once);

// LastGetKey: Key from most recent get
Assert.Equal(1, stub.Indexer.LastGetKey);

// Write uses Backing by default
repository[3] = new User { Id = 3, Name = "Charlie" };

// VerifySet: Check write count
stub.Indexer.VerifySet(Times.Once);

// LastSetEntry: Key-value tuple from most recent set
var lastEntry = stub.Indexer.LastSetEntry;
Assert.Equal(3, lastEntry?.Key);
Assert.Equal("Charlie", lastEntry?.Value?.Name);

// OnGet: Override Backing lookup
stub.Indexer.OnGet((key) => new User { Id = key, Name = "FromCallback" });
var fromCallback = repository[999];
Assert.Equal("FromCallback", fromCallback?.Name);

// IMPORTANT: OnSet does NOT auto-update Backing
var onSetCalled = false;
stub.Indexer.OnSet((key, value) =>
{
    onSetCalled = true;
    // To update Backing: stub.Indexer.Backing[key] = value;
});
repository[4] = new User { Id = 4 };
Assert.True(onSetCalled);
Assert.False(stub.Indexer.Backing.ContainsKey(4)); // Not in Backing
```
<!-- endSnippet -->

---

## Event Interceptor

Generated for interface events. Tracks add/remove operations, checks for subscribers, and provides `Raise` methods for firing events.

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `HasSubscribers` | `bool` | True if there are currently active subscribers |

### Verification Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `VerifyAdd()` | `void` | Verify event was subscribed at least once (throws if not) |
| `VerifyAdd(Times)` | `void` | Verify event was subscribed according to Times constraint |
| `VerifyRemove()` | `void` | Verify event was unsubscribed at least once (throws if not) |
| `VerifyRemove(Times)` | `void` | Verify event was unsubscribed according to Times constraint |
| `Verifiable()` | `{Interceptor}` | Mark event for batch verification with default constraint (AtLeastOnce), returns self for chaining |
| `Verifiable(Times)` | `{Interceptor}` | Mark event for batch verification with specific Times constraint, returns self for chaining |

### Methods

#### Raise Methods

The `Raise` method signature varies based on the event delegate type:

| Event Delegate | Raise Signature |
|---------------|-----------------|
| `Action` | `void Raise()` |
| `Action<T>` | `void Raise(T arg)` |
| `Action<T1, T2>` | `void Raise(T1 arg1, T2 arg2)` |
| `EventHandler` | `void Raise(object sender, EventArgs e)` |
| `EventHandler<TArgs>` | `void Raise(object sender, TArgs e)` |

Calling `Raise` invokes all subscribed handlers with the provided arguments.

#### Reset

- `void Reset()` - Clears tracking state. Does NOT remove subscribers

### Example

<!-- snippet: event-interceptor-complete-api-demo -->
```cs
// Subscribe to EventHandler event
var changedInvoked = false;
repository.Changed += (sender, e) => changedInvoked = true;

// VerifyAdd: Check subscription occurred
stub.Changed.VerifyAdd(Times.Once);

// HasSubscribers: Active subscription check
Assert.True(stub.Changed.HasSubscribers);

// Raise: Fire event to all subscribers
stub.Changed.Raise(repository, EventArgs.Empty);
Assert.True(changedInvoked);

// Unsubscribe tracking
EventHandler handler = (sender, e) => { };
repository.Changed += handler;
repository.Changed -= handler;

// VerifyRemove: Check unsubscription count
stub.Changed.VerifyRemove(Times.Once);

// Action<T> events: Same API, different Raise signature
User? addedUser = null;
repository.UserAdded += user => addedUser = user;

// Raise with typed argument
stub.UserAdded.Raise(new User { Id = 1, Name = "Alice" });
Assert.NotNull(addedUser);
Assert.Equal("Alice", addedUser.Name);
```
<!-- endSnippet -->

---

## Generic Method Interceptor

Generated for generic interface methods. Provides base-level tracking across all type arguments and typed access via `.Of<T>()` for specific type argument tracking.

### Base Properties

Available directly on the interceptor instance:

| Property | Type | Description |
|----------|------|-------------|
| `CalledTypeArguments` | `IReadOnlyList<Type>` | List of all type arguments used in calls (in order of first use) |

### Typed Access

Call `.Of<T>()` (or `.Of<T1, T2>()` for multiple type parameters) to get a typed interceptor for specific type arguments.

#### Typed Interceptor Access

Call `.Of<T>()` returns a typed interceptor with these properties:

| Property | Type | Description |
|----------|------|-------------|
| `OnCall` | Method | Configures callback/return value. Returns `IMethodTracking<T>` for accessing `LastArg` |

The typed tracking interface (`IMethodTracking<T>` or `IMethodTrackingArgs<TArgs>`) provides:

| Property | Type | Description |
|----------|------|-------------|
| `LastArg` | `TArg` | The argument from the most recent call with these type arguments (single-parameter methods) |
| `LastArgs` | `(TArg1, TArg2, ...)` | Tuple of arguments from the most recent call (multi-parameter methods) |

The `OnCall` method follows the same signature rules as non-generic method interceptors (see Method Interceptor section).

#### Typed Verification Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| `Of<T>().Verify()` | `void` | Verify method was called with these type arguments at least once (throws if not) |
| `Of<T>().Verify(Times)` | `void` | Verify method was called with these type arguments according to Times constraint |
| `Of<T>().Verifiable()` | `{TypedInterceptor}` | Mark typed interceptor for batch verification with default constraint (AtLeastOnce), returns self for chaining |
| `Of<T>().Verifiable(Times)` | `{TypedInterceptor}` | Mark typed interceptor for batch verification with specific Times constraint, returns self for chaining |

### Methods

- **Base Reset**: `void Reset()` - Clears all tracking and callbacks across all type arguments
- **Typed Reset**: `void Of<T>().Reset()` - Clears tracking and callback only for the specific type argument(s)

### Example

<!-- snippet: generic-method-interceptor-complete-api-demo -->
```cs
// .Of<T>(): Access typed interceptor for specific type argument
stub.GetById.Of<User>().OnCall((id) =>
    new User { Id = id, Name = $"User{id}" });

stub.GetById.Of<Product>().OnCall((id) =>
    new Product { Id = id, Name = $"Product{id}" });

// Call with different type arguments
var user1 = repository.GetById<User>(1);
var product = repository.GetById<Product>(2);
var user2 = repository.GetById<User>(3);

// CalledTypeArguments: List of all type arguments used
Assert.Contains(typeof(User), stub.GetById.CalledTypeArguments);
Assert.Contains(typeof(Product), stub.GetById.CalledTypeArguments);

// Typed verification: Per-type call counts
stub.GetById.Of<User>().Verify(Times.Exactly(2));
stub.GetById.Of<Product>().Verify(Times.Once);

// Typed LastCallArg: Per-type argument capture
Assert.Equal(3, stub.GetById.Of<User>().LastCallArg);
Assert.Equal(2, stub.GetById.Of<Product>().LastCallArg);

// Typed Reset: Clears only specific type
stub.GetById.Of<User>().Reset();
stub.GetById.Of<User>().Verify(Times.Never);
stub.GetById.Of<Product>().Verify(Times.Once); // Preserved

// Base Reset: Clears all type arguments
stub.GetById.Reset();
stub.GetById.Of<Product>().Verify(Times.Never);
```
<!-- endSnippet -->

---

## Reset Behavior Summary

All interceptors provide a `Reset()` method. This table summarizes what each reset clears and preserves:

| Interceptor Type | Reset Clears | Reset Preserves |
|-----------------|--------------|-----------------|
| **Method** | Tracking state, callbacks, sequence index | N/A |
| **Property** | Tracking state, `LastSetValue`, sequence indices | OnGet/OnSet callbacks, verifiable marking |
| **Indexer** | Tracking state, `LastGetKey`, `LastSetEntry`, sequence indices | `Backing` dictionary, OnGet/OnSet callbacks |
| **Event** | Tracking counts | Active subscribers, verifiable marking |
| **Generic Method (Base)** | All typed handlers cleared | N/A |
| **Generic Method (Typed)** | Tracking and callback for specific type argument(s) only | Tracking for other type arguments |

**Key Principle**: `Reset()` clears tracking state but preserves configuration (callbacks) and state that represents "what the stub currently is" (backing dictionaries, event subscribers).

---

## Times Constraint Reference

The `Times` struct is used with verification methods to specify expected call counts:

| Times Method | Description |
|-------------|-------------|
| `Times.Never` | Expected to not be called (0 times) |
| `Times.Once` | Expected to be called exactly once |
| `Times.Twice` | Expected to be called exactly twice |
| `Times.AtLeastOnce` | Expected to be called one or more times |
| `Times.Exactly(n)` | Expected to be called exactly n times |
| `Times.AtLeast(n)` | Expected to be called n or more times |
| `Times.AtMost(n)` | Expected to be called n or fewer times |

### Example

<!-- snippet: times-constraint-usage-examples -->
```cs
// Times.Never - Expected 0 calls
stub.Delete.Verify(Times.Never);

// Exercise stub
repository.GetById(1);
repository.Save(new User { Id = 1 });
repository.Save(new User { Id = 2 });

// Times.Once - Expected exactly 1 call
stub.GetById.Verify(Times.Once);

// Times.AtLeastOnce - Expected 1+ calls
stub.Save.Verify(Times.AtLeastOnce);

// Times.Exactly(n) - Expected exactly n calls
stub.Save.Verify(Times.Exactly(2));

// Times.AtLeast(n) - Expected n+ calls
stub.Save.Verify(Times.AtLeast(1));

// Times.AtMost(n) - Expected 0 to n calls
stub.GetById.Verify(Times.AtMost(5));
```
<!-- endSnippet -->

---

## Batch Verification

Stub classes provide a `Verify()` method that validates all interceptors marked as verifiable in a single call.

### Workflow

1. Mark interceptors using `Verifiable()` or `Verifiable(Times)`
2. Exercise the stub through the interface
3. Call `stub.Verify()` to validate all marked interceptors at once

### Example

<!-- snippet: batch-verification-workflow-example -->
```cs
// Step 1: Mark interceptors with Verifiable()
stub.GetById.OnCall((id) => new User { Id = id }).Verifiable();
stub.Save.OnCall((user) => { }).Verifiable(Times.Exactly(2));
stub.Delete.OnCall((id) => { }).Verifiable(Times.Never);

// Step 2: Exercise the stub through the interface
var user = repository.GetById(1);
repository.Save(user!);
repository.Save(new User { Id = 2 });
// Note: Delete is NOT called (expected per Times.Never)

// Step 3: Single Verify() call validates all marked interceptors
stub.Verify();
// Throws if any Verifiable() constraint is violated
```
<!-- endSnippet -->

If any verification fails, `Verify()` throws an exception detailing which interceptors failed and why.

---

## See Also

**Getting Started**:
- [Getting Started Guide](../../../../docs/getting-started.md) - Installation and first usage
- [Usage Patterns](./patterns.md) - Standalone, Inline Interface, and Inline Class patterns

**Feature Guides**:
- [Method Stubs](./methods.md) - Detailed guide to method interceptor features
- [Property Stubs](./properties.md) - Detailed guide to property interceptor features
- [Generic Methods](../../../../docs/guides/generic-methods.md) - Working with generic method interceptors
- [Events](../../../../docs/guides/events.md) - Event subscription tracking and raising
- [Verification](../../../../docs/guides/verification.md) - Advanced verification patterns and Times constraints

**Advanced Topics**:
- [Advanced Callbacks](../../../../docs/guides/advanced-callbacks.md) - Best practices for OnCall, OnGet, OnSet callbacks

---

**UPDATED:** 2026-01-25
