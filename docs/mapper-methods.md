# Mapper Methods

Mapper methods transfer data between domain models and Entity Framework entities.

## Overview

Domain models use mapper methods for data transfer:
- `MapFrom` - Manually implemented to load from EF entities (used in Fetch)
- `MapTo` - Manually implemented to copy to EF entities (used in Insert)
- `MapModifiedTo` - **Source-generated by Neatoo** to copy only modified properties (used in Update)

<!-- snippet: overview -->
```cs
/// <summary>
/// Person entity demonstrating MapFrom, MapTo, MapModifiedTo.
/// </summary>
public partial interface IPersonWithMapper : IEntityBase
{
    int Id { get; }
    string? FirstName { get; set; }
    string? LastName { get; set; }
    string? Email { get; set; }

    void MapFrom(PersonEntity entity);
    void MapTo(PersonEntity entity);
}

[Factory]
internal partial class PersonWithMapper : EntityBase<PersonWithMapper>, IPersonWithMapper
{
    public PersonWithMapper(IEntityBaseServices<PersonWithMapper> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? FirstName { get; set; }
    public partial string? LastName { get; set; }
    public partial string? Email { get; set; }

    // Manually implemented mappers
    public void MapFrom(PersonEntity entity)
    {
        this.Id = entity.Id;
        this.FirstName = entity.FirstName;
        this.LastName = entity.LastName;
        this.Email = entity.Email;
    }

    public void MapTo(PersonEntity entity)
    {
        entity.Id = this.Id;
        entity.FirstName = this.FirstName;
        entity.LastName = this.LastName;
        entity.Email = this.Email;
    }

    // Generated by Neatoo BaseGenerator - checks IsModified for each property
    public partial void MapModifiedTo(PersonEntity entity);

    [Create]
    public void Create()
    {
        // New person with no ID yet
    }

    [Fetch]
    public void Fetch(PersonEntity entity)
    {
        MapFrom(entity);
    }
}
```
<!-- endSnippet -->

## MapFrom

Maps from an EF entity to the domain model. Used in Fetch operations.

### Manual Implementation

<!-- snippet: map-from -->
```cs
/// <summary>
/// Demonstrates MapFrom usage in Fetch operations.
/// </summary>
public partial interface IFetchableProduct : IEntityBase
{
    int Id { get; }
    string? Name { get; set; }
    decimal Price { get; set; }
    int StockQuantity { get; set; }

    void MapFrom(ProductEntity entity);
}

public class ProductEntity
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public decimal Price { get; set; }
    public int StockQuantity { get; set; }
}

[Factory]
internal partial class FetchableProduct : EntityBase<FetchableProduct>, IFetchableProduct
{
    public FetchableProduct(IEntityBaseServices<FetchableProduct> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? Name { get; set; }
    public partial decimal Price { get; set; }
    public partial int StockQuantity { get; set; }

    public void MapFrom(ProductEntity entity)
    {
        this.Id = entity.Id;
        this.Name = entity.Name;
        this.Price = entity.Price;
        this.StockQuantity = entity.StockQuantity;
    }

    [Create]
    public void Create() { }

    /// <summary>
    /// Fetch operation uses MapFrom to load entity data.
    /// During Fetch, rules are paused via FactoryStart().
    /// </summary>
    [Fetch]
    public void Fetch(ProductEntity entity)
    {
        MapFrom(entity);  // Copy all properties
    }
}
```
<!-- endSnippet -->

### Usage

<!-- pseudo:mapfrom-usage -->
```csharp
[Fetch]
public async Task Fetch(int id, [Service] IDbContext db)
{
    var entity = await db.Persons.FindAsync(id);
    if (entity != null)
    {
        MapFrom(entity);  // Copy all properties
    }
}
```
<!-- /snippet -->

### Behavior

- Copies all matching properties from EF entity
- During `[Fetch]` operations, rules are automatically paused via `FactoryStart()`
- Properties are NOT marked as modified during factory operations
- Regular property setters work fine (no need for `LoadValue`)

## MapTo

Maps all properties from domain model to EF entity. Used in Insert operations.

### Manual Implementation

<!-- snippet: map-to -->
```cs
/// <summary>
/// Demonstrates MapTo usage in Insert operations.
/// </summary>
public partial interface IInsertableItem : IEntityBase
{
    int Id { get; }
    string? Description { get; set; }
    decimal Amount { get; set; }

    void MapTo(ItemEntity entity);
}

public class ItemEntity
{
    public int Id { get; set; }
    public string? Description { get; set; }
    public decimal Amount { get; set; }
}

[Factory]
internal partial class InsertableItem : EntityBase<InsertableItem>, IInsertableItem
{
    public InsertableItem(IEntityBaseServices<InsertableItem> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? Description { get; set; }
    public partial decimal Amount { get; set; }

    public void MapTo(ItemEntity entity)
    {
        entity.Description = this.Description;
        entity.Amount = this.Amount;
        // Note: ID is typically database-generated
    }

    [Create]
    public void Create() { }

    /// <summary>
    /// Insert uses MapTo to copy all properties to new entity.
    /// </summary>
    [Insert]
    public Task Insert()
    {
        // Simulate insert
        var entity = new ItemEntity();
        MapTo(entity);

        // Simulate database-generated ID
        entity.Id = 1;
        this.Id = entity.Id;

        return Task.CompletedTask;
    }
}
```
<!-- endSnippet -->

### Usage

<!-- pseudo:mapto-usage -->
```csharp
[Insert]
public async Task Insert([Service] IDbContext db)
{
    await RunRules();
    if (!IsSavable) return;

    var entity = new PersonEntity();
    MapTo(entity);  // Copy all properties
    db.Persons.Add(entity);
    await db.SaveChangesAsync();
}
```
<!-- /snippet -->

### Behavior

- Copies all matching properties by name
- Includes all properties, not just modified ones
- Used for new entity creation

## MapModifiedTo

Maps only modified properties. Used in Update operations for efficiency.

### Generated Implementation

<!-- snippet: map-modified-to -->
```cs
/// <summary>
/// Demonstrates MapModifiedTo for efficient updates.
/// </summary>
public partial interface IUpdatableRecord : IEntityBase
{
    int Id { get; }
    string? Title { get; set; }
    string? Content { get; set; }
    DateTime? LastModified { get; set; }

    void MapFrom(RecordEntity entity);
}

public class RecordEntity
{
    public int Id { get; set; }
    public string? Title { get; set; }
    public string? Content { get; set; }
    public DateTime? LastModified { get; set; }
}

[Factory]
internal partial class UpdatableRecord : EntityBase<UpdatableRecord>, IUpdatableRecord
{
    public UpdatableRecord(IEntityBaseServices<UpdatableRecord> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? Title { get; set; }
    public partial string? Content { get; set; }
    public partial DateTime? LastModified { get; set; }

    public void MapFrom(RecordEntity entity)
    {
        this.Id = entity.Id;
        this.Title = entity.Title;
        this.Content = entity.Content;
        this.LastModified = entity.LastModified;
    }

    // MapModifiedTo is source-generated - only updates IsModified properties
    public partial void MapModifiedTo(RecordEntity entity);

    [Create]
    public void Create() { }

    [Fetch]
    public void Fetch(RecordEntity entity)
    {
        MapFrom(entity);
    }

    /// <summary>
    /// Update uses MapModifiedTo for efficiency.
    /// Only modified properties are copied to the entity.
    /// </summary>
    [Update]
    public Task Update(RecordEntity entity)
    {
        MapModifiedTo(entity);  // Only changed properties
        return Task.CompletedTask;
    }
}
```
<!-- endSnippet -->

### Usage

<!-- pseudo:mapmodifiedto-usage -->
```csharp
[Update]
public async Task Update([Service] IDbContext db)
{
    await RunRules();
    if (!IsSavable) return;

    var entity = await db.Persons.FindAsync(Id);
    if (entity == null)
        throw new KeyNotFoundException("Person not found");

    MapModifiedTo(entity);  // Only changed properties
    await db.SaveChangesAsync();
}
```
<!-- /snippet -->

### Behavior

- Only updates properties where `IsModified = true`
- More efficient for partial updates
- Reduces unnecessary database writes
- Works with EF Core change tracking

## Property Matching

Properties are matched by name. The EF entity property name must match the domain model property name.

### Matching Rules

<!-- pseudo:property-matching-rules -->
```csharp
// Domain Model
public partial string? FirstName { get; set; }

// EF Entity - MUST match name
public string? FirstName { get; set; }  // OK
public string? First_Name { get; set; } // Won't map
```
<!-- /snippet -->

### Type Compatibility

Properties must have compatible types:

<!-- pseudo:type-compatibility -->
```csharp
// Domain Model
public partial int Age { get; set; }

// EF Entity
public int Age { get; set; }        // OK - exact match
public int? Age { get; set; }       // OK - nullable compatible
public string Age { get; set; }     // Error - type mismatch
```
<!-- /snippet -->

## Child Collections

Child collections are NOT handled by mapper methods. Map them explicitly:

<!-- pseudo:child-collections-mapping -->
```csharp
[Factory]
internal partial class Order : EntityBase<Order>, IOrder
{
    public partial IOrderLineItemList LineItems { get; set; }

    public partial void MapFrom(OrderEntity entity);
    public partial void MapTo(OrderEntity entity);

    [Fetch]
    public async Task Fetch(int id, [Service] IDbContext db,
                            [Service] IOrderLineItemListFactory listFactory)
    {
        var entity = await db.Orders.Include(o => o.LineItems).FirstOrDefaultAsync(o => o.Id == id);
        if (entity != null)
        {
            MapFrom(entity);
            // Explicitly map child collection
            LineItems = listFactory.Fetch(entity.LineItems);
        }
    }

    [Update]
    public async Task Update([Service] IDbContext db,
                             [Service] IOrderLineItemListFactory listFactory)
    {
        var entity = await db.Orders.Include(o => o.LineItems).FirstOrDefaultAsync(o => o.Id == Id);
        MapModifiedTo(entity);
        // Explicitly save child collection
        listFactory.Save(LineItems, entity.LineItems);
        await db.SaveChangesAsync();
    }
}
```
<!-- /snippet -->

## Custom Mapping Logic

For complex mappings, add custom logic after the generated mapper:

<!-- snippet: custom-mapping -->
```cs
/// <summary>
/// Demonstrates custom mapping logic for computed fields.
/// </summary>
public partial interface IEmployeeWithComputed : IEntityBase
{
    int Id { get; }
    string? FirstName { get; set; }
    string? LastName { get; set; }
    string? FullName { get; }
    string? PhoneType { get; set; }
}

public class EmployeeEntity
{
    public int Id { get; set; }
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public string? PhoneTypeString { get; set; }
}

[Factory]
internal partial class EmployeeWithComputed : EntityBase<EmployeeWithComputed>, IEmployeeWithComputed
{
    public EmployeeWithComputed(IEntityBaseServices<EmployeeWithComputed> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? FirstName { get; set; }
    public partial string? LastName { get; set; }

    // Computed property - not partial, excluded from mappers
    public string? FullName => $"{FirstName} {LastName}";

    public partial string? PhoneType { get; set; }

    [Create]
    public void Create() { }

    /// <summary>
    /// Custom mapping with computed fields and type conversions.
    /// </summary>
    [Fetch]
    public void Fetch(EmployeeEntity entity)
    {
        this.Id = entity.Id;
        this.FirstName = entity.FirstName;
        this.LastName = entity.LastName;

        // Custom mapping for type conversion
        this.PhoneType = entity.PhoneTypeString;
    }
}
```
<!-- endSnippet -->

## Excluding Properties

Properties not declared as `partial` are not included in generated mappers:

<!-- pseudo:property-exclusion -->
```csharp
[Factory]
internal partial class Person : EntityBase<Person>, IPerson
{
    // Included in mappers
    public partial string? FirstName { get; set; }
    public partial string? LastName { get; set; }

    // Excluded from mappers (not partial)
    public string FullName => $"{FirstName} {LastName}";  // Calculated
    public bool IsExpanded { get; set; }                   // UI-only
}
```
<!-- /snippet -->

## Different Entity Shapes

When domain model and EF entity have different structures:

<!-- snippet: different-shapes -->
```cs
/// <summary>
/// Demonstrates mapping between different entity structures.
/// Domain model has flat address fields, EF has nested Address object.
/// </summary>
public partial interface ICustomerWithAddress : IEntityBase
{
    int Id { get; }
    string? FirstName { get; set; }
    string? LastName { get; set; }
    string? StreetAddress { get; set; }
    string? City { get; set; }
    string? State { get; set; }
    string? ZipCode { get; set; }

    void MapFromEntity(CustomerEntity entity);
    void MapToEntity(CustomerEntity entity);
}

[Factory]
internal partial class CustomerWithAddress : EntityBase<CustomerWithAddress>, ICustomerWithAddress
{
    public CustomerWithAddress(IEntityBaseServices<CustomerWithAddress> services) : base(services) { }

    public partial int Id { get; set; }
    public partial string? FirstName { get; set; }
    public partial string? LastName { get; set; }
    public partial string? StreetAddress { get; set; }
    public partial string? City { get; set; }
    public partial string? State { get; set; }
    public partial string? ZipCode { get; set; }

    /// <summary>
    /// Custom mapping from nested EF structure to flat domain model.
    /// </summary>
    public void MapFromEntity(CustomerEntity entity)
    {
        Id = entity.Id;
        FirstName = entity.FirstName;
        LastName = entity.LastName;
        // EF has nested Address object
        StreetAddress = entity.Address?.Street;
        City = entity.Address?.City;
        State = entity.Address?.State;
        ZipCode = entity.Address?.ZipCode;
    }

    /// <summary>
    /// Custom mapping from flat domain model to nested EF structure.
    /// </summary>
    public void MapToEntity(CustomerEntity entity)
    {
        entity.Id = Id;
        entity.FirstName = FirstName;
        entity.LastName = LastName;
        entity.Address ??= new AddressEntity();
        entity.Address.Street = StreetAddress;
        entity.Address.City = City;
        entity.Address.State = State;
        entity.Address.ZipCode = ZipCode;
    }

    [Create]
    public void Create() { }

    [Fetch]
    public void Fetch(CustomerEntity entity)
    {
        MapFromEntity(entity);
    }

    [Insert]
    public Task Insert()
    {
        var entity = new CustomerEntity();
        MapToEntity(entity);
        // Simulate insert...
        return Task.CompletedTask;
    }
}
```
<!-- endSnippet -->

## Best Practices

### 1. Keep EF Entity Names Aligned

<!-- pseudo:keep-names-aligned -->
```csharp
// Domain Model
public partial string? CustomerName { get; set; }

// EF Entity - use same name
public string? CustomerName { get; set; }  // Good
public string? Name { get; set; }          // Won't auto-map
```
<!-- /snippet -->

### 2. Use MapModifiedTo for Updates

<!-- pseudo:use-mapmodifiedto -->
```csharp
// Efficient - only updates changed columns
[Update]
public async Task Update([Service] IDbContext db)
{
    var entity = await db.Persons.FindAsync(Id);
    if (entity == null)
        throw new KeyNotFoundException("Person not found");

    MapModifiedTo(entity);  // Only modified properties
    await db.SaveChangesAsync();
}
```
<!-- /snippet -->

### 3. Handle Null Entities

<!-- pseudo:handle-null-entities -->
```csharp
[Fetch]
public async Task<bool> Fetch(int id, [Service] IDbContext db)
{
    var entity = await db.Persons.FindAsync(id);
    if (entity == null)
        return false;

    MapFrom(entity);
    return true;
}
```
<!-- /snippet -->

### 4. Map ID After Insert

<!-- pseudo:map-id-after-insert -->
```csharp
[Insert]
public async Task Insert([Service] IDbContext db)
{
    var entity = new PersonEntity();
    MapTo(entity);
    db.Persons.Add(entity);
    await db.SaveChangesAsync();

    // Capture database-generated ID
    this.Id = entity.Id;
}
```
<!-- /snippet -->

## Generated Code Location

Only `MapModifiedTo` is source-generated. View the implementation in:
```
obj/Debug/net8.0/generated/Neatoo.BaseGenerator/
    Neatoo.BaseGenerator.MapModifiedToGenerator/
        DomainModel.PersonMapModifiedTo.g.cs
```

> **Note:** `MapFrom` and `MapTo` are manually implemented. The generated mapper feature
> was removed from RemoteFactory. See `docs/todos/remotefactory-mapper-removal-plan.md`.

## See Also

- [Factory Operations](factory-operations.md) - Using mappers in operations
- [Aggregates and Entities](aggregates-and-entities.md) - Domain model design
- [Collections](collections.md) - Child collection mapping
