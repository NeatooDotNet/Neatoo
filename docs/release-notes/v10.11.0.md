# Neatoo 10.11.0

**Release Date:** 2026-01-18
**Type:** Feature Release
**Breaking Changes:** No

---

## Summary

Introduces `LazyLoad<T>` wrapper type for explicit async lazy loading of entity relationships. Provides clear separation between accessing current state and triggering loads, with full meta-property delegation and error handling.

---

## What's New

### LazyLoad<T> Wrapper Type

Explicit async lazy loading for entity relationships with built-in state tracking:

```csharp
public partial class Consultation : EntityBase<Consultation>
{
    public LazyLoad<IHistory> History { get; private set; }

    public Consultation([Service] ILazyLoadFactory factory,
                        Func<int, Task<IHistory>> historyLoader)
    {
        History = factory.Create(() => historyLoader(Id));
    }
}
```

**Key Features:**
- `.Value` property never triggers a load - always returns current state
- Explicit loading via `await entity.History` or `.LoadAsync()`
- `IsLoading`, `IsLoaded`, `HasLoadError` properties for state tracking
- Implements `IValidateMetaProperties` and `IEntityMetaProperties` with delegation to wrapped value
- Concurrent load protection - multiple calls to `LoadAsync()` result in single execution

### UI Binding Support

`LazyLoad<T>` implements `INotifyPropertyChanged` for reactive UI updates:

```razor
@if (entity.History.IsLoading)
{
    <MudProgressCircular />
}
else if (entity.History.Value is { } history)
{
    <div>@history.Name</div>
}
```

### Error Handling

Load failures create broken rules on the entity via `HasLoadError`:

```csharp
var history = await entity.History;

if (entity.History.HasLoadError)
{
    // History.IsValid = false
    // History.PropertyMessages contains error
    // History.LoadError contains exception message
}
```

### ILazyLoadFactory

Create `LazyLoad<T>` instances via dependency injection:

```csharp
public interface ILazyLoadFactory
{
    // Create with lazy loader
    LazyLoad<TChild> Create<TChild>(Func<Task<TChild?>> loader)
        where TChild : class;

    // Create with pre-loaded value
    LazyLoad<TChild> Create<TChild>(TChild? value)
        where TChild : class;
}
```

Registered automatically in DI - inject via `[Service]` parameter.

### JSON Serialization

`LazyLoad<T>` serializes across client-server boundary:

```csharp
// Server-side: pre-loaded value
var consultation = factory.Fetch(id);
consultation.History = lazyLoadFactory.Create(history);

// Client receives: LazyLoad<T> with Value populated and IsLoaded = true
// No additional load required
```

### GetAwaiter Support

Clean `await` syntax without calling `.LoadAsync()`:

```csharp
// Both work identically:
var history = await entity.History.LoadAsync();
var history = await entity.History;  // GetAwaiter() support
```

---

## Usage Examples

### Entity Declaration

```csharp
public partial class Order : EntityBase<Order>
{
    public LazyLoad<ICustomer> Customer { get; private set; }

    public Order([Service] ILazyLoadFactory factory,
                 ICustomerRepository customerRepo)
    {
        Customer = factory.Create(async () =>
            await customerRepo.GetByIdAsync(CustomerId));
    }
}
```

### Pre-loaded Values

```csharp
[Fetch]
public async Task Fetch(int id,
                        ICustomerRepository customerRepo,
                        [Service] ILazyLoadFactory factory)
{
    var customer = await customerRepo.GetByIdAsync(CustomerId);
    Customer = factory.Create(customer);  // Already loaded
}
```

### Check Without Loading

```csharp
if (order.Customer.IsLoaded && order.Customer.Value!.IsVIP)
{
    // Only executes if already loaded
    ApplyVIPDiscount();
}
```

### Meta-Property Delegation

```csharp
// LazyLoad<T> bubbles up state from wrapped value
var isValid = order.Customer.IsValid;      // false if HasLoadError or wrapped value invalid
var isModified = order.Customer.IsModified; // true if wrapped value modified
var isBusy = order.Customer.IsBusy;        // true if loading or wrapped value busy
```

---

## Migration Guide

No breaking changes. `LazyLoad<T>` is a new opt-in feature.

If using the old `ValidateProperty<T>.OnLoad` pattern (removed in 10.10.0), migrate to `LazyLoad<T>`:

**Before (10.9.x):**
```csharp
public partial string Name { get; set; }

public Person()
{
    NameProperty.OnLoad = async () => await LoadNameAsync();
}
```

**After (10.11.0):**
```csharp
public LazyLoad<string> Name { get; private set; }

public Person([Service] ILazyLoadFactory factory)
{
    Name = factory.Create(LoadNameAsync);
}
```

---

## Related

- [Lazy Loading v2 Design](../todos/completed/lazy-loading-v2-design.md)
