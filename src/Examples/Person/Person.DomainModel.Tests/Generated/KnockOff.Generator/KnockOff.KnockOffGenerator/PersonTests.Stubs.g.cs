// <auto-generated/>
#nullable enable

namespace DomainModel.Tests.UnitTests;

partial class PersonTests
{
	/// <summary>Contains stub implementations for inline stub pattern.</summary>
	public static class Stubs
	{
		/// <summary>Interceptor for IPersonDbContext.Persons.</summary>
		public sealed class IPersonDbContext_PersonsInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonEntity>>? OnGet { get; set; }

			private global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonEntity> _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonEntity> Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonDbContext_PersonsInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonDbContext_PersonsInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Persons", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Persons (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Persons", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Persons", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonDbContext.PersonPhones.</summary>
		public sealed class IPersonDbContext_PersonPhonesInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonPhoneEntity>>? OnGet { get; set; }

			private global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonPhoneEntity> _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonPhoneEntity> Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonDbContext_PersonPhonesInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonDbContext_PersonPhonesInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PersonPhones", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PersonPhones (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("PersonPhones", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("PersonPhones", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Tracks and configures behavior for FindPerson.</summary>
		public sealed class IPersonDbContext_FindPersonInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for FindPerson(global::System.Threading.CancellationToken).</summary>
			public delegate global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(global::System.Threading.CancellationToken cancellationToken);

			private FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity? _onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity? _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			private global::System.Collections.Generic.List<(FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Tracking)>? _sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private int _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			private bool _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private global::KnockOff.Times? _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			/// <summary>Delegate for FindPerson(global::System.Guid?, global::System.Threading.CancellationToken).</summary>
			public delegate global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken);

			private FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity? _onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity? _onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			private global::System.Collections.Generic.List<(FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Callback, MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Tracking)>? _sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private int _sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			private bool _isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			private global::KnockOff.Times? _verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("FindPerson", times, TotalCallCount));
			}

			/// <summary>Configures callback for FindPerson(global::System.Threading.CancellationToken). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> OnCall(FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
			{
				_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = callback;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
				return _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			}

			/// <summary>Starts a callback sequence for FindPerson(global::System.Threading.CancellationToken). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> OnCallSequence(FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
			{
				_onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = new global::System.Collections.Generic.List<(FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Tracking)>();
				var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
				_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Add((callback, tracking));
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
				return new MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
			}

			/// <summary>Configures callback for FindPerson(global::System.Guid?, global::System.Threading.CancellationToken). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)> OnCall(FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
			{
				_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
				_isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = false;
				_verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = callback;
				_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = new MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
				return _onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
			}

			/// <summary>Starts a callback sequence for FindPerson(global::System.Guid?, global::System.Threading.CancellationToken). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> OnCallSequence(FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
			{
				_onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = false;
				_verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
				_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = new global::System.Collections.Generic.List<(FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Callback, MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity Tracking)>();
				var tracking = new MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
				_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Add((callback, tracking));
				_sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
				return new MethodSequenceImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(this);
			}

			/// <summary>Invokes configured callback for FindPerson(global::System.Threading.CancellationToken).</summary>
			internal global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> Invoke_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(bool strict, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity < _sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count)
				{
					var (callback, tracking) = _sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity[_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity];
					tracking.RecordCall(cancellationToken);
					_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity++;
					return callback(cancellationToken);
				}

				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null)
				{
					_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.RecordCall(cancellationToken);
					return _onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(cancellationToken);
				}

				_unconfiguredCallCount++;
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity >= _sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("FindPerson");
					return global::System.Threading.Tasks.Task.FromResult<global::Person.Ef.PersonEntity?>(default!);
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.FindPerson(cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "FindPerson");
				return global::System.Threading.Tasks.Task.FromResult<global::Person.Ef.PersonEntity?>(default!);
			}

			/// <summary>Invokes configured callback for FindPerson(global::System.Guid?, global::System.Threading.CancellationToken).</summary>
			internal global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> Invoke_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(bool strict, global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity < _sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count)
				{
					var (callback, tracking) = _sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity[_sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity];
					tracking.RecordCall((id, cancellationToken));
					_sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity++;
					return callback(id, cancellationToken);
				}

				if (_onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null)
				{
					_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.RecordCall((id, cancellationToken));
					return _onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(id, cancellationToken);
				}

				_unconfiguredCallCount++;
				if (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null && _sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity >= _sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("FindPerson");
					return global::System.Threading.Tasks.Task.FromResult<global::Person.Ef.PersonEntity?>(default!);
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.FindPerson(id, cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "FindPerson");
				return global::System.Threading.Tasks.Task.FromResult<global::Person.Ef.PersonEntity?>(default!);
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Reset();
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null)
				{
					foreach (var (_, tracking) in _sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
						tracking.Reset();
				}
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
				_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Reset();
				if (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null)
				{
					foreach (var (_, tracking) in _sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
						tracking.Reset();
				}
				_sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity || _isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Count ?? 0) > 0 || _onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null || (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
				{
					var times = _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("FindPerson", times, count);
				}
				if (_isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
				{
					var times = _verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("FindPerson", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("FindPerson", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity != null || (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.CallCount ?? 0) + (_sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("FindPerson", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity : global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken>
			{
				private readonly IPersonDbContext_FindPersonInterceptor _interceptor;

				public MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(IPersonDbContext_FindPersonInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.CancellationToken _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.CancellationToken LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.CancellationToken cancellationToken) { CallCount++; _lastArg = cancellationToken; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity : global::KnockOff.IMethodTrackingArgs<(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)>
			{
				private readonly IPersonDbContext_FindPersonInterceptor _interceptor;

				public MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(IPersonDbContext_FindPersonInterceptor interceptor) => _interceptor = interceptor;

				private (global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)> Verifiable()
				{
					_interceptor._isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity : global::KnockOff.IMethodSequence<FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity>
			{
				private readonly IPersonDbContext_FindPersonInterceptor _interceptor;

				public MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(IPersonDbContext_FindPersonInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> ThenCall(FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
				{
					var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(_interceptor);
					_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity == null) return;
					var sequenceLength = _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count;
					var completedCount = _interceptor._sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<FindPersonDelegate_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity : global::KnockOff.IMethodSequence<FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity>
			{
				private readonly IPersonDbContext_FindPersonInterceptor _interceptor;

				public MethodSequenceImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(IPersonDbContext_FindPersonInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> ThenCall(FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity callback)
				{
					var tracking = new MethodTrackingImpl_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(_interceptor);
					_interceptor._sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity == null) return;
					var sequenceLength = _interceptor._sequence_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity.Count;
					var completedCount = _interceptor._sequenceIndex_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<FindPersonDelegate_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity> Verifiable()
				{
					_interceptor._isVerifiable_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = true;
					_interceptor._verifiableTimes_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for AddPerson.</summary>
		public sealed class IPersonDbContext_AddPersonInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			private global::System.Action<global::Person.Ef.PersonEntity>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<global::Person.Ef.PersonEntity> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::Person.Ef.PersonEntity? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::Person.Ef.PersonEntity? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("AddPerson", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> OnCall(global::System.Action<global::Person.Ef.PersonEntity> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> OnCallSequence(global::System.Action<global::Person.Ef.PersonEntity> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<global::Person.Ef.PersonEntity> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, global::Person.Ef.PersonEntity personEntity)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(personEntity);
					_sequenceIndex++;
					callback(personEntity);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(personEntity);
					_onCall(personEntity);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = personEntity;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("AddPerson");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.AddPerson(personEntity); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "AddPerson");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddPerson", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddPerson", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity>
			{
				private readonly IPersonDbContext_AddPersonInterceptor _interceptor;

				public MethodTrackingImpl(IPersonDbContext_AddPersonInterceptor interceptor) => _interceptor = interceptor;

				private global::Person.Ef.PersonEntity _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::Person.Ef.PersonEntity LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::Person.Ef.PersonEntity personEntity) { CallCount++; _lastArg = personEntity; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>>
			{
				private readonly IPersonDbContext_AddPersonInterceptor _interceptor;

				public MethodSequenceImpl(IPersonDbContext_AddPersonInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> ThenCall(global::System.Action<global::Person.Ef.PersonEntity> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for DeleteAllPersons.</summary>
		public sealed class IPersonDbContext_DeleteAllPersonsInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			/// <summary>Delegate for DeleteAllPersons.</summary>
			public delegate global::System.Threading.Tasks.Task DeleteAllPersonsDelegate(global::System.Threading.CancellationToken cancellationToken);

			private DeleteAllPersonsDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(DeleteAllPersonsDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::System.Threading.CancellationToken? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::System.Threading.CancellationToken? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("DeleteAllPersons", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> OnCall(DeleteAllPersonsDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<DeleteAllPersonsDelegate> OnCallSequence(DeleteAllPersonsDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(DeleteAllPersonsDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Threading.Tasks.Task Invoke(bool strict, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(cancellationToken);
					_sequenceIndex++;
					return callback(cancellationToken);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(cancellationToken);
					return _onCall(cancellationToken);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = cancellationToken;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("DeleteAllPersons");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.DeleteAllPersons(cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "DeleteAllPersons");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("DeleteAllPersons", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("DeleteAllPersons", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken>
			{
				private readonly IPersonDbContext_DeleteAllPersonsInterceptor _interceptor;

				public MethodTrackingImpl(IPersonDbContext_DeleteAllPersonsInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.CancellationToken _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.CancellationToken LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.CancellationToken cancellationToken) { CallCount++; _lastArg = cancellationToken; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<DeleteAllPersonsDelegate>
			{
				private readonly IPersonDbContext_DeleteAllPersonsInterceptor _interceptor;

				public MethodSequenceImpl(IPersonDbContext_DeleteAllPersonsInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<DeleteAllPersonsDelegate> ThenCall(DeleteAllPersonsDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<DeleteAllPersonsDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for DeletePerson.</summary>
		public sealed class IPersonDbContext_DeletePersonInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			private global::System.Action<global::Person.Ef.PersonEntity>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<global::Person.Ef.PersonEntity> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::Person.Ef.PersonEntity? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::Person.Ef.PersonEntity? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("DeletePerson", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> OnCall(global::System.Action<global::Person.Ef.PersonEntity> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> OnCallSequence(global::System.Action<global::Person.Ef.PersonEntity> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<global::Person.Ef.PersonEntity> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, global::Person.Ef.PersonEntity person)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(person);
					_sequenceIndex++;
					callback(person);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(person);
					_onCall(person);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = person;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("DeletePerson");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.DeletePerson(person); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "DeletePerson");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("DeletePerson", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("DeletePerson", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity>
			{
				private readonly IPersonDbContext_DeletePersonInterceptor _interceptor;

				public MethodTrackingImpl(IPersonDbContext_DeletePersonInterceptor interceptor) => _interceptor = interceptor;

				private global::Person.Ef.PersonEntity _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::Person.Ef.PersonEntity LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::Person.Ef.PersonEntity person) { CallCount++; _lastArg = person; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::Person.Ef.PersonEntity> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>>
			{
				private readonly IPersonDbContext_DeletePersonInterceptor _interceptor;

				public MethodSequenceImpl(IPersonDbContext_DeletePersonInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> ThenCall(global::System.Action<global::Person.Ef.PersonEntity> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::Person.Ef.PersonEntity>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for SaveChangesAsync.</summary>
		public sealed class IPersonDbContext_SaveChangesAsyncInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Person.Ef.IPersonDbContext? _source;

			/// <summary>Delegate for SaveChangesAsync.</summary>
			public delegate global::System.Threading.Tasks.Task<int> SaveChangesAsyncDelegate(global::System.Threading.CancellationToken cancellationToken);

			private SaveChangesAsyncDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(SaveChangesAsyncDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::System.Threading.CancellationToken? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::System.Threading.CancellationToken? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("SaveChangesAsync", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> OnCall(SaveChangesAsyncDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<SaveChangesAsyncDelegate> OnCallSequence(SaveChangesAsyncDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(SaveChangesAsyncDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Threading.Tasks.Task<int> Invoke(bool strict, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(cancellationToken);
					_sequenceIndex++;
					return callback(cancellationToken);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(cancellationToken);
					return _onCall(cancellationToken);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = cancellationToken;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("SaveChangesAsync");
					return global::System.Threading.Tasks.Task.FromResult<int>(default!);
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.SaveChangesAsync(cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "SaveChangesAsync");
				return global::System.Threading.Tasks.Task.FromResult<int>(default!);
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("SaveChangesAsync", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("SaveChangesAsync", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken>
			{
				private readonly IPersonDbContext_SaveChangesAsyncInterceptor _interceptor;

				public MethodTrackingImpl(IPersonDbContext_SaveChangesAsyncInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.CancellationToken _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.CancellationToken LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.CancellationToken cancellationToken) { CallCount++; _lastArg = cancellationToken; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<SaveChangesAsyncDelegate>
			{
				private readonly IPersonDbContext_SaveChangesAsyncInterceptor _interceptor;

				public MethodSequenceImpl(IPersonDbContext_SaveChangesAsyncInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<SaveChangesAsyncDelegate> ThenCall(SaveChangesAsyncDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<SaveChangesAsyncDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Stub implementation of global::Person.Ef.IPersonDbContext.</summary>
		public class IPersonDbContext : global::Person.Ef.IPersonDbContext, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for Persons.</summary>
			public IPersonDbContext_PersonsInterceptor Persons { get; } = new();

			/// <summary>Interceptor for PersonPhones.</summary>
			public IPersonDbContext_PersonPhonesInterceptor PersonPhones { get; } = new();

			/// <summary>Interceptor for FindPerson.</summary>
			public IPersonDbContext_FindPersonInterceptor FindPerson { get; } = new();

			/// <summary>Interceptor for AddPerson.</summary>
			public IPersonDbContext_AddPersonInterceptor AddPerson { get; } = new();

			/// <summary>Interceptor for DeleteAllPersons.</summary>
			public IPersonDbContext_DeleteAllPersonsInterceptor DeleteAllPersons { get; } = new();

			/// <summary>Interceptor for DeletePerson.</summary>
			public IPersonDbContext_DeletePersonInterceptor DeletePerson { get; } = new();

			/// <summary>Interceptor for SaveChangesAsync.</summary>
			public IPersonDbContext_SaveChangesAsyncInterceptor SaveChangesAsync { get; } = new();

			global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> global::Person.Ef.IPersonDbContext.FindPerson(global::System.Threading.CancellationToken cancellationToken)
			{
				return FindPerson.Invoke_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(Strict, cancellationToken);
			}

			global::System.Threading.Tasks.Task<global::Person.Ef.PersonEntity?> global::Person.Ef.IPersonDbContext.FindPerson(global::System.Guid? id, global::System.Threading.CancellationToken cancellationToken)
			{
				return FindPerson.Invoke_Guid_Threading_CancellationToken_Threading_Tasks_Task_Person_Ef_PersonEntity(Strict, id, cancellationToken);
			}

			void global::Person.Ef.IPersonDbContext.AddPerson(global::Person.Ef.PersonEntity personEntity)
			{
				AddPerson.Invoke(Strict, personEntity);
			}

			global::System.Threading.Tasks.Task global::Person.Ef.IPersonDbContext.DeleteAllPersons(global::System.Threading.CancellationToken cancellationToken)
			{
				return DeleteAllPersons.Invoke(Strict, cancellationToken);
			}

			void global::Person.Ef.IPersonDbContext.DeletePerson(global::Person.Ef.PersonEntity person)
			{
				DeletePerson.Invoke(Strict, person);
			}

			global::System.Threading.Tasks.Task<int> global::Person.Ef.IPersonDbContext.SaveChangesAsync(global::System.Threading.CancellationToken cancellationToken)
			{
				return SaveChangesAsync.Invoke(Strict, cancellationToken);
			}

			global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonEntity> global::Person.Ef.IPersonDbContext.Persons
			{
				get
				{
					Persons.RecordGet();
					if (Persons.OnGet is { } onGet) return onGet();
					if (Persons._source is { } src) return src.Persons;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonDbContext", "Persons");
					return Persons.Value;
				}
			}

			global::Microsoft.EntityFrameworkCore.DbSet<global::Person.Ef.PersonPhoneEntity> global::Person.Ef.IPersonDbContext.PersonPhones
			{
				get
				{
					PersonPhones.RecordGet();
					if (PersonPhones.OnGet is { } onGet) return onGet();
					if (PersonPhones._source is { } src) return src.PersonPhones;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonDbContext", "PersonPhones");
					return PersonPhones.Value;
				}
			}

			/// <summary>The global::Person.Ef.IPersonDbContext instance. Use for passing to code expecting the interface.</summary>
			public global::Person.Ef.IPersonDbContext Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IPersonDbContext(bool strict = false)
			{
				Strict = strict;
			}

			/// <summary>Sets the source object for global::Person.Ef.IPersonDbContext delegation.</summary>
			public void Source(global::Person.Ef.IPersonDbContext? source)
			{
				Persons._source = source;
				PersonPhones._source = source;
				FindPerson._source = source;
				AddPerson._source = source;
				DeleteAllPersons._source = source;
				DeletePerson._source = source;
				SaveChangesAsync._source = source;
			}

			/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>
			public void Verify()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Persons.CheckVerification() is { } personsFailure) failures.Add(personsFailure);
				if (PersonPhones.CheckVerification() is { } personphonesFailure) failures.Add(personphonesFailure);
				if (FindPerson.CheckVerification() is { } findpersonFailure) failures.Add(findpersonFailure);
				if (AddPerson.CheckVerification() is { } addpersonFailure) failures.Add(addpersonFailure);
				if (DeleteAllPersons.CheckVerification() is { } deleteallpersonsFailure) failures.Add(deleteallpersonsFailure);
				if (DeletePerson.CheckVerification() is { } deletepersonFailure) failures.Add(deletepersonFailure);
				if (SaveChangesAsync.CheckVerification() is { } savechangesasyncFailure) failures.Add(savechangesasyncFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

			/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>
			public void VerifyAll()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Persons.CheckVerificationAll() is { } personsFailure) failures.Add(personsFailure);
				if (PersonPhones.CheckVerificationAll() is { } personphonesFailure) failures.Add(personphonesFailure);
				if (FindPerson.CheckVerificationAll() is { } findpersonFailure) failures.Add(findpersonFailure);
				if (AddPerson.CheckVerificationAll() is { } addpersonFailure) failures.Add(addpersonFailure);
				if (DeleteAllPersons.CheckVerificationAll() is { } deleteallpersonsFailure) failures.Add(deleteallpersonsFailure);
				if (DeletePerson.CheckVerificationAll() is { } deletepersonFailure) failures.Add(deletepersonFailure);
				if (SaveChangesAsync.CheckVerificationAll() is { } savechangesasyncFailure) failures.Add(savechangesasyncFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

		}

		/// <summary>Tracks and configures behavior for Fetch.</summary>
		public sealed class IPersonPhoneListFactory_FetchInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::DomainModel.IPersonPhoneListFactory? _source;

			/// <summary>Delegate for Fetch.</summary>
			public delegate global::DomainModel.IPersonPhoneList FetchDelegate(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken);

			private FetchDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(FetchDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private (global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)? _unconfiguredLastArgs;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)? LastCallArgs { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArgs; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Fetch", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> OnCall(FetchDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<FetchDelegate> OnCallSequence(FetchDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(FetchDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::DomainModel.IPersonPhoneList Invoke(bool strict, global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall((personPhoneEntities, cancellationToken));
					_sequenceIndex++;
					return callback(personPhoneEntities, cancellationToken);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall((personPhoneEntities, cancellationToken));
					return _onCall(personPhoneEntities, cancellationToken);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArgs = ((personPhoneEntities, cancellationToken));
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Fetch");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.Fetch(personPhoneEntities, cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Fetch");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Fetch", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Fetch", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)>
			{
				private readonly IPersonPhoneListFactory_FetchInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneListFactory_FetchInterceptor interceptor) => _interceptor = interceptor;

				private (global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<FetchDelegate>
			{
				private readonly IPersonPhoneListFactory_FetchInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneListFactory_FetchInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<FetchDelegate> ThenCall(FetchDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<FetchDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Save.</summary>
		public sealed class IPersonPhoneListFactory_SaveInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::DomainModel.IPersonPhoneListFactory? _source;

			/// <summary>Delegate for Save.</summary>
			public delegate global::DomainModel.IPersonPhoneList SaveDelegate(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken);

			private SaveDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(SaveDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private (global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)? _unconfiguredLastArgs;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)? LastCallArgs { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArgs; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Save", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> OnCall(SaveDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<SaveDelegate> OnCallSequence(SaveDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(SaveDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::DomainModel.IPersonPhoneList Invoke(bool strict, global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall((target, personPhoneEntities, cancellationToken));
					_sequenceIndex++;
					return callback(target, personPhoneEntities, cancellationToken);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall((target, personPhoneEntities, cancellationToken));
					return _onCall(target, personPhoneEntities, cancellationToken);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArgs = ((target, personPhoneEntities, cancellationToken));
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Save");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.Save(target, personPhoneEntities, cancellationToken);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Save");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Save", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Save", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)>
			{
				private readonly IPersonPhoneListFactory_SaveInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneListFactory_SaveInterceptor interceptor) => _interceptor = interceptor;

				private (global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<SaveDelegate>
			{
				private readonly IPersonPhoneListFactory_SaveInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneListFactory_SaveInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<SaveDelegate> ThenCall(SaveDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<SaveDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Stub implementation of global::DomainModel.IPersonPhoneListFactory.</summary>
		public class IPersonPhoneListFactory : global::DomainModel.IPersonPhoneListFactory, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for Fetch.</summary>
			public IPersonPhoneListFactory_FetchInterceptor Fetch { get; } = new();

			/// <summary>Interceptor for Save.</summary>
			public IPersonPhoneListFactory_SaveInterceptor Save { get; } = new();

			global::DomainModel.IPersonPhoneList global::DomainModel.IPersonPhoneListFactory.Fetch(global::System.Collections.Generic.IEnumerable<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)
			{
				return Fetch.Invoke(Strict, personPhoneEntities, cancellationToken);
			}

			global::DomainModel.IPersonPhoneList global::DomainModel.IPersonPhoneListFactory.Save(global::DomainModel.IPersonPhoneList target, global::System.Collections.Generic.ICollection<global::Person.Ef.PersonPhoneEntity> personPhoneEntities, global::System.Threading.CancellationToken cancellationToken)
			{
				return Save.Invoke(Strict, target, personPhoneEntities, cancellationToken);
			}

			/// <summary>The global::DomainModel.IPersonPhoneListFactory instance. Use for passing to code expecting the interface.</summary>
			public global::DomainModel.IPersonPhoneListFactory Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IPersonPhoneListFactory(bool strict = false)
			{
				Strict = strict;
			}

			/// <summary>Sets the source object for global::DomainModel.IPersonPhoneListFactory delegation.</summary>
			public void Source(global::DomainModel.IPersonPhoneListFactory? source)
			{
				Fetch._source = source;
				Save._source = source;
			}

			/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>
			public void Verify()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Fetch.CheckVerification() is { } fetchFailure) failures.Add(fetchFailure);
				if (Save.CheckVerification() is { } saveFailure) failures.Add(saveFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

			/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>
			public void VerifyAll()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Fetch.CheckVerificationAll() is { } fetchFailure) failures.Add(fetchFailure);
				if (Save.CheckVerificationAll() is { } saveFailure) failures.Add(saveFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

		}

		/// <summary>Interceptor for IPersonPhoneList.Parent.</summary>
		public sealed class IPersonPhoneList_ParentInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::Neatoo.IValidateBase?>? OnGet { get; set; }

			private global::Neatoo.IValidateBase? _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::Neatoo.IValidateBase? Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateListBase<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_ParentInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_ParentInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Parent", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Parent (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Parent", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Parent", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.Count.</summary>
		public sealed class IPersonPhoneList_CountInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<int>? OnGet { get; set; }

			private int _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public int Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_CountInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_CountInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Count", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Count (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Count", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Count", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsReadOnly.</summary>
		public sealed class IPersonPhoneList_IsReadOnlyInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsReadOnlyInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsReadOnlyInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsReadOnly", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsReadOnly (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsReadOnly", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsReadOnly", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsBusy.</summary>
		public sealed class IPersonPhoneList_IsBusyInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsBusyInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsBusyInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsBusy", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsBusy (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsBusy", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsBusy", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsValid.</summary>
		public sealed class IPersonPhoneList_IsValidInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsValidInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsValidInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsValid", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsValid (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsValid", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsValid", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsSelfValid.</summary>
		public sealed class IPersonPhoneList_IsSelfValidInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSelfValidInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSelfValidInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfValid", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfValid (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsSelfValid", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsSelfValid", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.PropertyMessages.</summary>
		public sealed class IPersonPhoneList_PropertyMessagesInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage>>? OnGet { get; set; }

			private global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_PropertyMessagesInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_PropertyMessagesInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PropertyMessages", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PropertyMessages (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("PropertyMessages", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("PropertyMessages", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsChild.</summary>
		public sealed class IPersonPhoneList_IsChildInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IEntityMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsChildInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsChildInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsChild", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsChild (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsChild", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsChild", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsModified.</summary>
		public sealed class IPersonPhoneList_IsModifiedInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IEntityMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsModifiedInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsModifiedInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsModified", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsModified (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsModified", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsModified", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsSelfModified.</summary>
		public sealed class IPersonPhoneList_IsSelfModifiedInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IEntityMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSelfModifiedInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSelfModifiedInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfModified", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfModified (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsSelfModified", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsSelfModified", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsMarkedModified.</summary>
		public sealed class IPersonPhoneList_IsMarkedModifiedInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IEntityMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsMarkedModifiedInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsMarkedModifiedInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsMarkedModified", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsMarkedModified (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsMarkedModified", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsMarkedModified", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsSavable.</summary>
		public sealed class IPersonPhoneList_IsSavableInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IEntityMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSavableInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsSavableInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSavable", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSavable (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsSavable", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsSavable", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsDeleted.</summary>
		public sealed class IPersonPhoneList_IsDeletedInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.RemoteFactory.IFactorySaveMeta? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsDeletedInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsDeletedInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsDeleted", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsDeleted (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsDeleted", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsDeleted", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.IsNew.</summary>
		public sealed class IPersonPhoneList_IsNewInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.RemoteFactory.IFactorySaveMeta? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsNewInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IsNewInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsNew", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsNew (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsNew", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsNew", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.Indexer.</summary>
		public sealed class IPersonPhoneList_IndexerInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _configured;

			private int _getCount;

			/// <summary>The last key used to access the getter.</summary>
			public int? LastGetKey { get; private set; }

			private global::System.Func<int, global::DomainModel.IPersonPhone>? _onGet;
			/// <summary>Callback for getter. Setting this marks the indexer as configured.</summary>
			public global::System.Func<int, global::DomainModel.IPersonPhone>? OnGet
			{
				get => _onGet;
				set { _onGet = value; if (value != null) _configured = true; }
			}

			private int _setCount;

			/// <summary>The last key-value pair passed to the setter.</summary>
			public (int Key, global::DomainModel.IPersonPhone Value)? LastSetEntry { get; private set; }

			private global::System.Action<int, global::DomainModel.IPersonPhone>? _onSet;
			/// <summary>Callback for setter. Setting this marks the indexer as configured.</summary>
			public global::System.Action<int, global::DomainModel.IPersonPhone>? OnSet
			{
				get => _onSet;
				set { _onSet = value; if (value != null) _configured = true; }
			}

			/// <summary>Records a getter access.</summary>
			public void RecordGet(int index) { _getCount++; LastGetKey = index; }

			/// <summary>Records a setter access.</summary>
			public void RecordSet(int index, global::DomainModel.IPersonPhone value) { _setCount++; LastSetEntry = (index, value); }

			/// <summary>Backing storage for this indexer.</summary>
			public global::System.Collections.Generic.Dictionary<int, global::DomainModel.IPersonPhone> Backing { get; } = new();

			/// <summary>Source object for delegation when OnGet/OnSet is not set.</summary>
			internal global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Resets tracking state (counts, LastGetKey, LastSetEntry) but preserves configuration (OnGet, OnSet, Backing) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; LastGetKey = default; _setCount = 0; LastSetEntry = default; _source = null; }

			/// <summary>Marks this indexer for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IndexerInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this indexer for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_IndexerInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the indexer was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount + _setCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Indexer", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Indexer (get)", times, _getCount));
			}

			/// <summary>Verifies the setter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifySet() => VerifySet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies setter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifySet(global::KnockOff.Times times)
			{
				if (!times.Validate(_setCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Indexer (set)", times, _setCount));
			}

			/// <summary>Whether this indexer was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this indexer has been configured (callbacks registered).</summary>
			internal bool IsConfigured => _configured;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount + _setCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Indexer", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount + _setCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Indexer", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Tracks and configures behavior for AddPhoneNumber.</summary>
		public sealed class IPersonPhoneList_AddPhoneNumberInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::DomainModel.IPersonPhoneList? _source;

			/// <summary>Delegate for AddPhoneNumber.</summary>
			public delegate global::DomainModel.IPersonPhone AddPhoneNumberDelegate();

			private AddPhoneNumberDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(AddPhoneNumberDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("AddPhoneNumber", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(AddPhoneNumberDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<AddPhoneNumberDelegate> OnCallSequence(AddPhoneNumberDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(AddPhoneNumberDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::DomainModel.IPersonPhone Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					return callback();
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					return _onCall();
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("AddPhoneNumber");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.AddPhoneNumber();
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "AddPhoneNumber");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddPhoneNumber", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddPhoneNumber", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_AddPhoneNumberInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_AddPhoneNumberInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<AddPhoneNumberDelegate>
			{
				private readonly IPersonPhoneList_AddPhoneNumberInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_AddPhoneNumberInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<AddPhoneNumberDelegate> ThenCall(AddPhoneNumberDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<AddPhoneNumberDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for RemovePhoneNumber.</summary>
		public sealed class IPersonPhoneList_RemovePhoneNumberInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::DomainModel.IPersonPhoneList? _source;

			/// <summary>Delegate for RemovePhoneNumber.</summary>
			public delegate global::System.Threading.Tasks.Task RemovePhoneNumberDelegate(global::DomainModel.IPersonPhone personPhoneModel);

			private RemovePhoneNumberDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(RemovePhoneNumberDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::DomainModel.IPersonPhone? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::DomainModel.IPersonPhone? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RemovePhoneNumber", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> OnCall(RemovePhoneNumberDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<RemovePhoneNumberDelegate> OnCallSequence(RemovePhoneNumberDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(RemovePhoneNumberDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Threading.Tasks.Task Invoke(bool strict, global::DomainModel.IPersonPhone personPhoneModel)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(personPhoneModel);
					_sequenceIndex++;
					return callback(personPhoneModel);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(personPhoneModel);
					return _onCall(personPhoneModel);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = personPhoneModel;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RemovePhoneNumber");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RemovePhoneNumber(personPhoneModel);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RemovePhoneNumber");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RemovePhoneNumber", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RemovePhoneNumber", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone>
			{
				private readonly IPersonPhoneList_RemovePhoneNumberInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_RemovePhoneNumberInterceptor interceptor) => _interceptor = interceptor;

				private global::DomainModel.IPersonPhone _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::DomainModel.IPersonPhone LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::DomainModel.IPersonPhone personPhoneModel) { CallCount++; _lastArg = personPhoneModel; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<RemovePhoneNumberDelegate>
			{
				private readonly IPersonPhoneList_RemovePhoneNumberInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_RemovePhoneNumberInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RemovePhoneNumberDelegate> ThenCall(RemovePhoneNumberDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RemovePhoneNumberDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for RemoveAt.</summary>
		public sealed class IPersonPhoneList_RemoveAtInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IEntityListBase<global::DomainModel.IPersonPhone>? _source;

			private global::System.Action<int>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<int> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private int? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public int? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RemoveAt", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<int> OnCall(global::System.Action<int> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<int>> OnCallSequence(global::System.Action<int> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<int> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, int index)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(index);
					_sequenceIndex++;
					callback(index);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(index);
					_onCall(index);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = index;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RemoveAt");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.RemoveAt(index); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RemoveAt");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RemoveAt", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RemoveAt", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<int>
			{
				private readonly IPersonPhoneList_RemoveAtInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_RemoveAtInterceptor interceptor) => _interceptor = interceptor;

				private int _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public int LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(int index) { CallCount++; _lastArg = index; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<int> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<int> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<int>>
			{
				private readonly IPersonPhoneList_RemoveAtInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_RemoveAtInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<int>> ThenCall(global::System.Action<int> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<int>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for IndexOf.</summary>
		public sealed class IPersonPhoneList_IndexOfInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Delegate for IndexOf.</summary>
			public delegate int IndexOfDelegate(global::DomainModel.IPersonPhone item);

			private IndexOfDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(IndexOfDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::DomainModel.IPersonPhone? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::DomainModel.IPersonPhone? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IndexOf", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> OnCall(IndexOfDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<IndexOfDelegate> OnCallSequence(IndexOfDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(IndexOfDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal int Invoke(bool strict, global::DomainModel.IPersonPhone item)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(item);
					_sequenceIndex++;
					return callback(item);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(item);
					return _onCall(item);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = item;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("IndexOf");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.IndexOf(item);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "IndexOf");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("IndexOf", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("IndexOf", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone>
			{
				private readonly IPersonPhoneList_IndexOfInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_IndexOfInterceptor interceptor) => _interceptor = interceptor;

				private global::DomainModel.IPersonPhone _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::DomainModel.IPersonPhone LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::DomainModel.IPersonPhone item) { CallCount++; _lastArg = item; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<IndexOfDelegate>
			{
				private readonly IPersonPhoneList_IndexOfInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_IndexOfInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<IndexOfDelegate> ThenCall(IndexOfDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<IndexOfDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Insert.</summary>
		public sealed class IPersonPhoneList_InsertInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>? _source;

			private global::System.Action<int, global::DomainModel.IPersonPhone>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<int, global::DomainModel.IPersonPhone> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private (int index, global::DomainModel.IPersonPhone item)? _unconfiguredLastArgs;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (int index, global::DomainModel.IPersonPhone item)? LastCallArgs { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArgs; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Insert", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTrackingArgs<(int index, global::DomainModel.IPersonPhone item)> OnCall(global::System.Action<int, global::DomainModel.IPersonPhone> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<int, global::DomainModel.IPersonPhone>> OnCallSequence(global::System.Action<int, global::DomainModel.IPersonPhone> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<int, global::DomainModel.IPersonPhone> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, int index, global::DomainModel.IPersonPhone item)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall((index, item));
					_sequenceIndex++;
					callback(index, item);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall((index, item));
					_onCall(index, item);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArgs = ((index, item));
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Insert");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.Insert(index, item); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Insert");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Insert", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Insert", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(int index, global::DomainModel.IPersonPhone item)>
			{
				private readonly IPersonPhoneList_InsertInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_InsertInterceptor interceptor) => _interceptor = interceptor;

				private (int index, global::DomainModel.IPersonPhone item) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (int index, global::DomainModel.IPersonPhone item) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((int index, global::DomainModel.IPersonPhone item) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(int index, global::DomainModel.IPersonPhone item)> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(int index, global::DomainModel.IPersonPhone item)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<int, global::DomainModel.IPersonPhone>>
			{
				private readonly IPersonPhoneList_InsertInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_InsertInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<int, global::DomainModel.IPersonPhone>> ThenCall(global::System.Action<int, global::DomainModel.IPersonPhone> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<int, global::DomainModel.IPersonPhone>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Add.</summary>
		public sealed class IPersonPhoneList_AddInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			private global::System.Action<global::DomainModel.IPersonPhone>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<global::DomainModel.IPersonPhone> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::DomainModel.IPersonPhone? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::DomainModel.IPersonPhone? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Add", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> OnCall(global::System.Action<global::DomainModel.IPersonPhone> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone>> OnCallSequence(global::System.Action<global::DomainModel.IPersonPhone> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<global::DomainModel.IPersonPhone> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, global::DomainModel.IPersonPhone item)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(item);
					_sequenceIndex++;
					callback(item);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(item);
					_onCall(item);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = item;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Add");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.Add(item); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Add");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Add", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Add", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone>
			{
				private readonly IPersonPhoneList_AddInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_AddInterceptor interceptor) => _interceptor = interceptor;

				private global::DomainModel.IPersonPhone _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::DomainModel.IPersonPhone LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::DomainModel.IPersonPhone item) { CallCount++; _lastArg = item; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone>>
			{
				private readonly IPersonPhoneList_AddInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_AddInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone>> ThenCall(global::System.Action<global::DomainModel.IPersonPhone> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Clear.</summary>
		public sealed class IPersonPhoneList_ClearInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			private global::System.Action? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Clear", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action> OnCallSequence(global::System.Action callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					callback();
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					_onCall();
					return;
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Clear");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.Clear(); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Clear");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Clear", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Clear", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_ClearInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_ClearInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action>
			{
				private readonly IPersonPhoneList_ClearInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_ClearInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> ThenCall(global::System.Action callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Contains.</summary>
		public sealed class IPersonPhoneList_ContainsInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Delegate for Contains.</summary>
			public delegate bool ContainsDelegate(global::DomainModel.IPersonPhone item);

			private ContainsDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(ContainsDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::DomainModel.IPersonPhone? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::DomainModel.IPersonPhone? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Contains", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> OnCall(ContainsDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<ContainsDelegate> OnCallSequence(ContainsDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(ContainsDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal bool Invoke(bool strict, global::DomainModel.IPersonPhone item)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(item);
					_sequenceIndex++;
					return callback(item);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(item);
					return _onCall(item);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = item;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Contains");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.Contains(item);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Contains");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Contains", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Contains", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone>
			{
				private readonly IPersonPhoneList_ContainsInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_ContainsInterceptor interceptor) => _interceptor = interceptor;

				private global::DomainModel.IPersonPhone _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::DomainModel.IPersonPhone LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::DomainModel.IPersonPhone item) { CallCount++; _lastArg = item; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<ContainsDelegate>
			{
				private readonly IPersonPhoneList_ContainsInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_ContainsInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<ContainsDelegate> ThenCall(ContainsDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<ContainsDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for CopyTo.</summary>
		public sealed class IPersonPhoneList_CopyToInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			private global::System.Action<global::DomainModel.IPersonPhone[], int>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<global::DomainModel.IPersonPhone[], int> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private (global::DomainModel.IPersonPhone[] array, int arrayIndex)? _unconfiguredLastArgs;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (global::DomainModel.IPersonPhone[] array, int arrayIndex)? LastCallArgs { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArgs; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("CopyTo", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhone[] array, int arrayIndex)> OnCall(global::System.Action<global::DomainModel.IPersonPhone[], int> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone[], int>> OnCallSequence(global::System.Action<global::DomainModel.IPersonPhone[], int> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<global::DomainModel.IPersonPhone[], int> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, global::DomainModel.IPersonPhone[] array, int arrayIndex)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall((array, arrayIndex));
					_sequenceIndex++;
					callback(array, arrayIndex);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall((array, arrayIndex));
					_onCall(array, arrayIndex);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArgs = ((array, arrayIndex));
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("CopyTo");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.CopyTo(array, arrayIndex); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "CopyTo");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("CopyTo", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("CopyTo", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhone[] array, int arrayIndex)>
			{
				private readonly IPersonPhoneList_CopyToInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_CopyToInterceptor interceptor) => _interceptor = interceptor;

				private (global::DomainModel.IPersonPhone[] array, int arrayIndex) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::DomainModel.IPersonPhone[] array, int arrayIndex) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::DomainModel.IPersonPhone[] array, int arrayIndex) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhone[] array, int arrayIndex)> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::DomainModel.IPersonPhone[] array, int arrayIndex)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone[], int>>
			{
				private readonly IPersonPhoneList_CopyToInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_CopyToInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone[], int>> ThenCall(global::System.Action<global::DomainModel.IPersonPhone[], int> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::DomainModel.IPersonPhone[], int>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for Remove.</summary>
		public sealed class IPersonPhoneList_RemoveInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Delegate for Remove.</summary>
			public delegate bool RemoveDelegate(global::DomainModel.IPersonPhone item);

			private RemoveDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(RemoveDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::DomainModel.IPersonPhone? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::DomainModel.IPersonPhone? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Remove", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> OnCall(RemoveDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<RemoveDelegate> OnCallSequence(RemoveDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(RemoveDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal bool Invoke(bool strict, global::DomainModel.IPersonPhone item)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(item);
					_sequenceIndex++;
					return callback(item);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(item);
					return _onCall(item);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = item;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("Remove");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.Remove(item);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "Remove");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Remove", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("Remove", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone>
			{
				private readonly IPersonPhoneList_RemoveInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_RemoveInterceptor interceptor) => _interceptor = interceptor;

				private global::DomainModel.IPersonPhone _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::DomainModel.IPersonPhone LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::DomainModel.IPersonPhone item) { CallCount++; _lastArg = item; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::DomainModel.IPersonPhone> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<RemoveDelegate>
			{
				private readonly IPersonPhoneList_RemoveInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_RemoveInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RemoveDelegate> ThenCall(RemoveDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RemoveDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for GetEnumerator.</summary>
		public sealed class IPersonPhoneList_GetEnumeratorInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::System.Collections.Generic.IEnumerable<global::DomainModel.IPersonPhone>? _source;

			/// <summary>Delegate for GetEnumerator.</summary>
			public delegate global::System.Collections.Generic.IEnumerator<global::DomainModel.IPersonPhone> GetEnumeratorDelegate();

			private GetEnumeratorDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(GetEnumeratorDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("GetEnumerator", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(GetEnumeratorDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<GetEnumeratorDelegate> OnCallSequence(GetEnumeratorDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(GetEnumeratorDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Collections.Generic.IEnumerator<global::DomainModel.IPersonPhone> Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					return callback();
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					return _onCall();
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("GetEnumerator");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.GetEnumerator();
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "GetEnumerator");
				throw new global::System.InvalidOperationException("No implementation provided for GetEnumerator. Configure via OnCall.");
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("GetEnumerator", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("GetEnumerator", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_GetEnumeratorInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_GetEnumeratorInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<GetEnumeratorDelegate>
			{
				private readonly IPersonPhoneList_GetEnumeratorInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_GetEnumeratorInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<GetEnumeratorDelegate> ThenCall(GetEnumeratorDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<GetEnumeratorDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for WaitForTasks.</summary>
		public sealed class IPersonPhoneList_WaitForTasksInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for WaitForTasks().</summary>
			public delegate global::System.Threading.Tasks.Task WaitForTasksDelegate_NoParams_Threading_Tasks_Task();

			private WaitForTasksDelegate_NoParams_Threading_Tasks_Task? _onCall_NoParams_Threading_Tasks_Task;
			private MethodTrackingImpl_NoParams_Threading_Tasks_Task? _onCallTracking_NoParams_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(WaitForTasksDelegate_NoParams_Threading_Tasks_Task Callback, MethodTrackingImpl_NoParams_Threading_Tasks_Task Tracking)>? _sequence_NoParams_Threading_Tasks_Task;
			private int _sequenceIndex_NoParams_Threading_Tasks_Task;

			private bool _isVerifiable_NoParams_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_NoParams_Threading_Tasks_Task;

			/// <summary>Delegate for WaitForTasks(global::System.Threading.CancellationToken).</summary>
			public delegate global::System.Threading.Tasks.Task WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task(global::System.Threading.CancellationToken token);

			private WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task? _onCall_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("WaitForTasks", times, TotalCallCount));
			}

			/// <summary>Configures callback for WaitForTasks(). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
			{
				_sequence_NoParams_Threading_Tasks_Task = null;
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				_isVerifiable_NoParams_Threading_Tasks_Task = false;
				_verifiableTimes_NoParams_Threading_Tasks_Task = null;
				_onCall_NoParams_Threading_Tasks_Task = callback;
				_onCallTracking_NoParams_Threading_Tasks_Task = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(this);
				return _onCallTracking_NoParams_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for WaitForTasks(). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> OnCallSequence(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
			{
				_onCall_NoParams_Threading_Tasks_Task = null;
				_onCallTracking_NoParams_Threading_Tasks_Task = null;
				_isVerifiable_NoParams_Threading_Tasks_Task = false;
				_verifiableTimes_NoParams_Threading_Tasks_Task = null;
				_sequence_NoParams_Threading_Tasks_Task = new global::System.Collections.Generic.List<(WaitForTasksDelegate_NoParams_Threading_Tasks_Task Callback, MethodTrackingImpl_NoParams_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(this);
				_sequence_NoParams_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_NoParams_Threading_Tasks_Task(this);
			}

			/// <summary>Configures callback for WaitForTasks(global::System.Threading.CancellationToken). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> OnCall(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for WaitForTasks(global::System.Threading.CancellationToken). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Invokes configured callback for WaitForTasks().</summary>
			internal global::System.Threading.Tasks.Task Invoke_NoParams_Threading_Tasks_Task(bool strict)
			{
				if (_sequence_NoParams_Threading_Tasks_Task != null && _sequenceIndex_NoParams_Threading_Tasks_Task < _sequence_NoParams_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_NoParams_Threading_Tasks_Task[_sequenceIndex_NoParams_Threading_Tasks_Task];
					tracking.RecordCall();
					_sequenceIndex_NoParams_Threading_Tasks_Task++;
					return callback();
				}

				if (_onCall_NoParams_Threading_Tasks_Task != null && _onCallTracking_NoParams_Threading_Tasks_Task != null)
				{
					_onCallTracking_NoParams_Threading_Tasks_Task.RecordCall();
					return _onCall_NoParams_Threading_Tasks_Task();
				}

				_unconfiguredCallCount++;
				if (_sequence_NoParams_Threading_Tasks_Task != null && _sequenceIndex_NoParams_Threading_Tasks_Task >= _sequence_NoParams_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("WaitForTasks");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.WaitForTasks();
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "WaitForTasks");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Invokes configured callback for WaitForTasks(global::System.Threading.CancellationToken).</summary>
			internal global::System.Threading.Tasks.Task Invoke_Threading_CancellationToken_Threading_Tasks_Task(bool strict, global::System.Threading.CancellationToken token)
			{
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task < _sequence_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall(token);
					_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(token);
				}

				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task.RecordCall(token);
					return _onCall_Threading_CancellationToken_Threading_Tasks_Task(token);
				}

				_unconfiguredCallCount++;
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("WaitForTasks");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.WaitForTasks(token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "WaitForTasks");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_NoParams_Threading_Tasks_Task?.Reset();
				if (_sequence_NoParams_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_NoParams_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_NoParams_Threading_Tasks_Task || _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_NoParams_Threading_Tasks_Task != null || (_sequence_NoParams_Threading_Tasks_Task?.Count ?? 0) > 0 || _onCall_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_NoParams_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_NoParams_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", times, count);
				}
				if (_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_NoParams_Threading_Tasks_Task != null || (_sequence_NoParams_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_NoParams_Threading_Tasks_Task : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_WaitForTasksInterceptor _interceptor;

				public MethodTrackingImpl_NoParams_Threading_Tasks_Task(IPersonPhoneList_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = times;
					return this;
				}
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken>
			{
				private readonly IPersonPhoneList_WaitForTasksInterceptor _interceptor;

				public MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.CancellationToken _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.CancellationToken LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.CancellationToken token) { CallCount++; _lastArg = token; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_NoParams_Threading_Tasks_Task : global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task>
			{
				private readonly IPersonPhoneList_WaitForTasksInterceptor _interceptor;

				public MethodSequenceImpl_NoParams_Threading_Tasks_Task(IPersonPhoneList_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_NoParams_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_NoParams_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> ThenCall(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_NoParams_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_NoParams_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_NoParams_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_NoParams_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IPersonPhoneList_WaitForTasksInterceptor _interceptor;

				public MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for RunRules.</summary>
		public sealed class IPersonPhoneList_RunRulesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task(string propertyName, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task? _onCall_String_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_String_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Delegate for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RunRules", times, TotalCallCount));
			}

			/// <summary>Configures callback for RunRules(string, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(string, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Configures callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Invokes configured callback for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(bool strict, string propertyName, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task < _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_String_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((propertyName, token));
					_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(propertyName, token);
				}

				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((propertyName, token));
					return _onCall_String_Threading_CancellationToken_Threading_Tasks_Task(propertyName, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(propertyName, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Invokes configured callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(bool strict, global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task < _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((runRules, token));
					_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(runRules, token);
				}

				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((runRules, token));
					return _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(runRules, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(runRules, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task || _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0 || _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				if (_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)>
			{
				private readonly IPersonPhoneList_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (string propertyName, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (string propertyName, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((string propertyName, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)>
			{
				private readonly IPersonPhoneList_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IPersonPhoneList_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IPersonPhoneList_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IPersonPhoneList_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for ClearAllMessages.</summary>
		public sealed class IPersonPhoneList_ClearAllMessagesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private global::System.Action? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("ClearAllMessages", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action> OnCallSequence(global::System.Action callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					callback();
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					_onCall();
					return;
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("ClearAllMessages");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.ClearAllMessages(); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "ClearAllMessages");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearAllMessages", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearAllMessages", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_ClearAllMessagesInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_ClearAllMessagesInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action>
			{
				private readonly IPersonPhoneList_ClearAllMessagesInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_ClearAllMessagesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> ThenCall(global::System.Action callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for ClearSelfMessages.</summary>
		public sealed class IPersonPhoneList_ClearSelfMessagesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private global::System.Action? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("ClearSelfMessages", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action> OnCallSequence(global::System.Action callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					callback();
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					_onCall();
					return;
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("ClearSelfMessages");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.ClearSelfMessages(); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "ClearSelfMessages");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearSelfMessages", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearSelfMessages", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IPersonPhoneList_ClearSelfMessagesInterceptor _interceptor;

				public MethodTrackingImpl(IPersonPhoneList_ClearSelfMessagesInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action>
			{
				private readonly IPersonPhoneList_ClearSelfMessagesInterceptor _interceptor;

				public MethodSequenceImpl(IPersonPhoneList_ClearSelfMessagesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> ThenCall(global::System.Action callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Interceptor for IPersonPhoneList.CollectionChanged event.</summary>
		public sealed class IPersonPhoneList_CollectionChangedInterceptor
		{
			private int _addCount;
			private int _removeCount;

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.Collections.Specialized.NotifyCollectionChangedEventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.Collections.Specialized.NotifyCollectionChangedEventHandler? handler) { _addCount++; Handler = (global::System.Collections.Specialized.NotifyCollectionChangedEventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.Collections.Specialized.NotifyCollectionChangedEventHandler? handler) { _removeCount++; Handler = (global::System.Collections.Specialized.NotifyCollectionChangedEventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets tracking state (counts, Handler) but preserves verifiable marking.</summary>
			public void Reset() { _addCount = 0; _removeCount = 0; Handler = null; }

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			/// <summary>Verifies the event was subscribed to at least once.</summary>
			public void VerifyAdd() => VerifyAdd(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event subscription count matches the Times constraint.</summary>
			public void VerifyAdd(global::KnockOff.Times times)
			{
				if (!times.Validate(_addCount))
					throw new global::KnockOff.VerificationException($"Event 'CollectionChanged' add verification failed: expected {times}, but was called {_addCount} time(s).");
			}

			/// <summary>Verifies the event was unsubscribed at least once.</summary>
			public void VerifyRemove() => VerifyRemove(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event unsubscription count matches the Times constraint.</summary>
			public void VerifyRemove(global::KnockOff.Times times)
			{
				if (!times.Validate(_removeCount))
					throw new global::KnockOff.VerificationException($"Event 'CollectionChanged' remove verification failed: expected {times}, but was called {_removeCount} time(s).");
			}

			/// <summary>Verifies the event was accessed (add or remove) at least once.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the total event access count matches the Times constraint.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException($"Event 'CollectionChanged' verification failed: expected {times}, but was called {totalCount} time(s).");
			}

			/// <summary>Marks this event for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_CollectionChangedInterceptor Verifiable()
			{
				_isVerifiable = true;
				_verifiableTimes = global::KnockOff.Times.AtLeastOnce;
				return this;
			}

			/// <summary>Marks this event for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_CollectionChangedInterceptor Verifiable(global::KnockOff.Times times)
			{
				_isVerifiable = true;
				_verifiableTimes = times;
				return this;
			}

			internal bool IsVerifiable => _isVerifiable;
			internal bool IsConfigured => Handler != null;

			/// <summary>Checks verification for Stub.Verify() - only verifiable items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("CollectionChanged", times, totalCount);
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - all configured items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured && !_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("CollectionChanged", times, totalCount);
				return null;
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.PropertyChanged event.</summary>
		public sealed class IPersonPhoneList_PropertyChangedInterceptor
		{
			private int _addCount;
			private int _removeCount;

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.ComponentModel.PropertyChangedEventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.ComponentModel.PropertyChangedEventHandler? handler) { _addCount++; Handler = (global::System.ComponentModel.PropertyChangedEventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.ComponentModel.PropertyChangedEventHandler? handler) { _removeCount++; Handler = (global::System.ComponentModel.PropertyChangedEventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets tracking state (counts, Handler) but preserves verifiable marking.</summary>
			public void Reset() { _addCount = 0; _removeCount = 0; Handler = null; }

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			/// <summary>Verifies the event was subscribed to at least once.</summary>
			public void VerifyAdd() => VerifyAdd(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event subscription count matches the Times constraint.</summary>
			public void VerifyAdd(global::KnockOff.Times times)
			{
				if (!times.Validate(_addCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' add verification failed: expected {times}, but was called {_addCount} time(s).");
			}

			/// <summary>Verifies the event was unsubscribed at least once.</summary>
			public void VerifyRemove() => VerifyRemove(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event unsubscription count matches the Times constraint.</summary>
			public void VerifyRemove(global::KnockOff.Times times)
			{
				if (!times.Validate(_removeCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' remove verification failed: expected {times}, but was called {_removeCount} time(s).");
			}

			/// <summary>Verifies the event was accessed (add or remove) at least once.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the total event access count matches the Times constraint.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' verification failed: expected {times}, but was called {totalCount} time(s).");
			}

			/// <summary>Marks this event for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_PropertyChangedInterceptor Verifiable()
			{
				_isVerifiable = true;
				_verifiableTimes = global::KnockOff.Times.AtLeastOnce;
				return this;
			}

			/// <summary>Marks this event for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_PropertyChangedInterceptor Verifiable(global::KnockOff.Times times)
			{
				_isVerifiable = true;
				_verifiableTimes = times;
				return this;
			}

			internal bool IsVerifiable => _isVerifiable;
			internal bool IsConfigured => Handler != null;

			/// <summary>Checks verification for Stub.Verify() - only verifiable items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("PropertyChanged", times, totalCount);
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - all configured items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured && !_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("PropertyChanged", times, totalCount);
				return null;
			}
		}

		/// <summary>Interceptor for IPersonPhoneList.NeatooPropertyChanged event.</summary>
		public sealed class IPersonPhoneList_NeatooPropertyChangedInterceptor
		{
			private int _addCount;
			private int _removeCount;

			/// <summary>The backing delegate for raising the event.</summary>
			public global::Neatoo.NeatooPropertyChanged? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::Neatoo.NeatooPropertyChanged? handler) { _addCount++; Handler = (global::Neatoo.NeatooPropertyChanged?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::Neatoo.NeatooPropertyChanged? handler) { _removeCount++; Handler = (global::Neatoo.NeatooPropertyChanged?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets tracking state (counts, Handler) but preserves verifiable marking.</summary>
			public void Reset() { _addCount = 0; _removeCount = 0; Handler = null; }

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			/// <summary>Verifies the event was subscribed to at least once.</summary>
			public void VerifyAdd() => VerifyAdd(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event subscription count matches the Times constraint.</summary>
			public void VerifyAdd(global::KnockOff.Times times)
			{
				if (!times.Validate(_addCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' add verification failed: expected {times}, but was called {_addCount} time(s).");
			}

			/// <summary>Verifies the event was unsubscribed at least once.</summary>
			public void VerifyRemove() => VerifyRemove(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event unsubscription count matches the Times constraint.</summary>
			public void VerifyRemove(global::KnockOff.Times times)
			{
				if (!times.Validate(_removeCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' remove verification failed: expected {times}, but was called {_removeCount} time(s).");
			}

			/// <summary>Verifies the event was accessed (add or remove) at least once.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the total event access count matches the Times constraint.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' verification failed: expected {times}, but was called {totalCount} time(s).");
			}

			/// <summary>Marks this event for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IPersonPhoneList_NeatooPropertyChangedInterceptor Verifiable()
			{
				_isVerifiable = true;
				_verifiableTimes = global::KnockOff.Times.AtLeastOnce;
				return this;
			}

			/// <summary>Marks this event for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IPersonPhoneList_NeatooPropertyChangedInterceptor Verifiable(global::KnockOff.Times times)
			{
				_isVerifiable = true;
				_verifiableTimes = times;
				return this;
			}

			internal bool IsVerifiable => _isVerifiable;
			internal bool IsConfigured => Handler != null;

			/// <summary>Checks verification for Stub.Verify() - only verifiable items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("NeatooPropertyChanged", times, totalCount);
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - all configured items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured && !_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("NeatooPropertyChanged", times, totalCount);
				return null;
			}
		}

		/// <summary>Stub implementation of global::DomainModel.IPersonPhoneList.</summary>
		public class IPersonPhoneList : global::DomainModel.IPersonPhoneList, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for Parent.</summary>
			public IPersonPhoneList_ParentInterceptor Parent { get; } = new();

			/// <summary>Interceptor for Count.</summary>
			public IPersonPhoneList_CountInterceptor Count { get; } = new();

			/// <summary>Interceptor for IsReadOnly.</summary>
			public IPersonPhoneList_IsReadOnlyInterceptor IsReadOnly { get; } = new();

			/// <summary>Interceptor for IsBusy.</summary>
			public IPersonPhoneList_IsBusyInterceptor IsBusy { get; } = new();

			/// <summary>Interceptor for IsValid.</summary>
			public IPersonPhoneList_IsValidInterceptor IsValid { get; } = new();

			/// <summary>Interceptor for IsSelfValid.</summary>
			public IPersonPhoneList_IsSelfValidInterceptor IsSelfValid { get; } = new();

			/// <summary>Interceptor for PropertyMessages.</summary>
			public IPersonPhoneList_PropertyMessagesInterceptor PropertyMessages { get; } = new();

			/// <summary>Interceptor for IsChild.</summary>
			public IPersonPhoneList_IsChildInterceptor IsChild { get; } = new();

			/// <summary>Interceptor for IsModified.</summary>
			public IPersonPhoneList_IsModifiedInterceptor IsModified { get; } = new();

			/// <summary>Interceptor for IsSelfModified.</summary>
			public IPersonPhoneList_IsSelfModifiedInterceptor IsSelfModified { get; } = new();

			/// <summary>Interceptor for IsMarkedModified.</summary>
			public IPersonPhoneList_IsMarkedModifiedInterceptor IsMarkedModified { get; } = new();

			/// <summary>Interceptor for IsSavable.</summary>
			public IPersonPhoneList_IsSavableInterceptor IsSavable { get; } = new();

			/// <summary>Interceptor for IsDeleted.</summary>
			public IPersonPhoneList_IsDeletedInterceptor IsDeleted { get; } = new();

			/// <summary>Interceptor for IsNew.</summary>
			public IPersonPhoneList_IsNewInterceptor IsNew { get; } = new();

			/// <summary>Interceptor for indexer.</summary>
			public IPersonPhoneList_IndexerInterceptor Indexer { get; } = new();

			/// <summary>Interceptor for AddPhoneNumber.</summary>
			public IPersonPhoneList_AddPhoneNumberInterceptor AddPhoneNumber { get; } = new();

			/// <summary>Interceptor for RemovePhoneNumber.</summary>
			public IPersonPhoneList_RemovePhoneNumberInterceptor RemovePhoneNumber { get; } = new();

			/// <summary>Interceptor for RemoveAt.</summary>
			public IPersonPhoneList_RemoveAtInterceptor RemoveAt { get; } = new();

			/// <summary>Interceptor for IndexOf.</summary>
			public IPersonPhoneList_IndexOfInterceptor IndexOf { get; } = new();

			/// <summary>Interceptor for Insert.</summary>
			public IPersonPhoneList_InsertInterceptor Insert { get; } = new();

			/// <summary>Interceptor for Add.</summary>
			public IPersonPhoneList_AddInterceptor Add { get; } = new();

			/// <summary>Interceptor for Clear.</summary>
			public IPersonPhoneList_ClearInterceptor Clear { get; } = new();

			/// <summary>Interceptor for Contains.</summary>
			public IPersonPhoneList_ContainsInterceptor Contains { get; } = new();

			/// <summary>Interceptor for CopyTo.</summary>
			public IPersonPhoneList_CopyToInterceptor CopyTo { get; } = new();

			/// <summary>Interceptor for Remove.</summary>
			public IPersonPhoneList_RemoveInterceptor Remove { get; } = new();

			/// <summary>Interceptor for GetEnumerator.</summary>
			public IPersonPhoneList_GetEnumeratorInterceptor GetEnumerator { get; } = new();

			/// <summary>Interceptor for WaitForTasks.</summary>
			public IPersonPhoneList_WaitForTasksInterceptor WaitForTasks { get; } = new();

			/// <summary>Interceptor for RunRules.</summary>
			public IPersonPhoneList_RunRulesInterceptor RunRules { get; } = new();

			/// <summary>Interceptor for ClearAllMessages.</summary>
			public IPersonPhoneList_ClearAllMessagesInterceptor ClearAllMessages { get; } = new();

			/// <summary>Interceptor for ClearSelfMessages.</summary>
			public IPersonPhoneList_ClearSelfMessagesInterceptor ClearSelfMessages { get; } = new();

			/// <summary>Interceptor for CollectionChanged event.</summary>
			public IPersonPhoneList_CollectionChangedInterceptor CollectionChangedInterceptor { get; } = new();

			/// <summary>Interceptor for PropertyChanged event.</summary>
			public IPersonPhoneList_PropertyChangedInterceptor PropertyChangedInterceptor { get; } = new();

			/// <summary>Interceptor for NeatooPropertyChanged event.</summary>
			public IPersonPhoneList_NeatooPropertyChangedInterceptor NeatooPropertyChangedInterceptor { get; } = new();

			global::DomainModel.IPersonPhone global::DomainModel.IPersonPhoneList.AddPhoneNumber()
			{
				return AddPhoneNumber.Invoke(Strict);
			}

			global::System.Threading.Tasks.Task global::DomainModel.IPersonPhoneList.RemovePhoneNumber(global::DomainModel.IPersonPhone personPhoneModel)
			{
				return RemovePhoneNumber.Invoke(Strict, personPhoneModel);
			}

			void global::Neatoo.IEntityListBase<global::DomainModel.IPersonPhone>.RemoveAt(int index)
			{
				RemoveAt.Invoke(Strict, index);
			}

			global::Neatoo.IValidateBase? global::Neatoo.IValidateListBase<global::DomainModel.IPersonPhone>.Parent
			{
				get
				{
					Parent.RecordGet();
					if (Parent.OnGet is { } onGet) return onGet();
					if (Parent._source is { } src) return src.Parent;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonPhone>", "Parent");
					return Parent.Value;
				}
			}

			int global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>.IndexOf(global::DomainModel.IPersonPhone item)
			{
				return IndexOf.Invoke(Strict, item);
			}

			void global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>.Insert(int index, global::DomainModel.IPersonPhone item)
			{
				Insert.Invoke(Strict, index, item);
			}

			void global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>.RemoveAt(int index)
			{
				RemoveAt.Invoke(Strict, index);
			}

			global::DomainModel.IPersonPhone global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>.this[int index]
			{
				get
				{
					Indexer.RecordGet(index);
					if (Indexer.OnGet is { } onGet) return onGet(index);
					if (Indexer._source is { } src) return src[index];
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonPhone>", "this[]");
					return Indexer.Backing.TryGetValue(index, out var v) ? v : default!;
				}
				set
				{
					Indexer.RecordSet(index, value);
					if (Indexer.OnSet is { } onSet) { onSet(index, value); return; }
					if (Indexer._source is { } src) { src[index] = value; return; }
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonPhone>", "this[]");
					Indexer.Backing[index] = value;
				}
			}

			void global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.Add(global::DomainModel.IPersonPhone item)
			{
				Add.Invoke(Strict, item);
			}

			void global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.Clear()
			{
				Clear.Invoke(Strict);
			}

			bool global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.Contains(global::DomainModel.IPersonPhone item)
			{
				return Contains.Invoke(Strict, item);
			}

			void global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.CopyTo(global::DomainModel.IPersonPhone[] array, int arrayIndex)
			{
				CopyTo.Invoke(Strict, array, arrayIndex);
			}

			bool global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.Remove(global::DomainModel.IPersonPhone item)
			{
				return Remove.Invoke(Strict, item);
			}

			int global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.Count
			{
				get
				{
					Count.RecordGet();
					if (Count.OnGet is { } onGet) return onGet();
					if (Count._source is { } src) return src.Count;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonPhone>", "Count");
					return Count.Value;
				}
			}

			bool global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>.IsReadOnly
			{
				get
				{
					IsReadOnly.RecordGet();
					if (IsReadOnly.OnGet is { } onGet) return onGet();
					if (IsReadOnly._source is { } src) return src.IsReadOnly;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IPersonPhone>", "IsReadOnly");
					return IsReadOnly.Value;
				}
			}

			global::System.Collections.Generic.IEnumerator<global::DomainModel.IPersonPhone> global::System.Collections.Generic.IEnumerable<global::DomainModel.IPersonPhone>.GetEnumerator()
			{
				return GetEnumerator.Invoke(Strict);
			}

			global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
			{
				return GetEnumerator.Invoke(Strict);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.WaitForTasks()
			{
				return WaitForTasks.Invoke_NoParams_Threading_Tasks_Task(Strict);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.WaitForTasks(global::System.Threading.CancellationToken token)
			{
				return WaitForTasks.Invoke_Threading_CancellationToken_Threading_Tasks_Task(Strict, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.RunRules(string propertyName, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(Strict, propertyName, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.RunRules(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(Strict, runRules, token);
			}

			void global::Neatoo.IValidateMetaProperties.ClearAllMessages()
			{
				ClearAllMessages.Invoke(Strict);
			}

			void global::Neatoo.IValidateMetaProperties.ClearSelfMessages()
			{
				ClearSelfMessages.Invoke(Strict);
			}

			bool global::Neatoo.IValidateMetaProperties.IsBusy
			{
				get
				{
					IsBusy.RecordGet();
					if (IsBusy.OnGet is { } onGet) return onGet();
					if (IsBusy._source is { } src) return src.IsBusy;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsBusy");
					return IsBusy.Value;
				}
			}

			bool global::Neatoo.IValidateMetaProperties.IsValid
			{
				get
				{
					IsValid.RecordGet();
					if (IsValid.OnGet is { } onGet) return onGet();
					if (IsValid._source is { } src) return src.IsValid;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsValid");
					return IsValid.Value;
				}
			}

			bool global::Neatoo.IValidateMetaProperties.IsSelfValid
			{
				get
				{
					IsSelfValid.RecordGet();
					if (IsSelfValid.OnGet is { } onGet) return onGet();
					if (IsSelfValid._source is { } src) return src.IsSelfValid;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsSelfValid");
					return IsSelfValid.Value;
				}
			}

			global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> global::Neatoo.IValidateMetaProperties.PropertyMessages
			{
				get
				{
					PropertyMessages.RecordGet();
					if (PropertyMessages.OnGet is { } onGet) return onGet();
					if (PropertyMessages._source is { } src) return src.PropertyMessages;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "PropertyMessages");
					return PropertyMessages.Value;
				}
			}

			bool global::Neatoo.IEntityMetaProperties.IsChild
			{
				get
				{
					IsChild.RecordGet();
					if (IsChild.OnGet is { } onGet) return onGet();
					if (IsChild._source is { } src) return src.IsChild;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IEntityMetaProperties", "IsChild");
					return IsChild.Value;
				}
			}

			bool global::Neatoo.IEntityMetaProperties.IsModified
			{
				get
				{
					IsModified.RecordGet();
					if (IsModified.OnGet is { } onGet) return onGet();
					if (IsModified._source is { } src) return src.IsModified;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IEntityMetaProperties", "IsModified");
					return IsModified.Value;
				}
			}

			bool global::Neatoo.IEntityMetaProperties.IsSelfModified
			{
				get
				{
					IsSelfModified.RecordGet();
					if (IsSelfModified.OnGet is { } onGet) return onGet();
					if (IsSelfModified._source is { } src) return src.IsSelfModified;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IEntityMetaProperties", "IsSelfModified");
					return IsSelfModified.Value;
				}
			}

			bool global::Neatoo.IEntityMetaProperties.IsMarkedModified
			{
				get
				{
					IsMarkedModified.RecordGet();
					if (IsMarkedModified.OnGet is { } onGet) return onGet();
					if (IsMarkedModified._source is { } src) return src.IsMarkedModified;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IEntityMetaProperties", "IsMarkedModified");
					return IsMarkedModified.Value;
				}
			}

			bool global::Neatoo.IEntityMetaProperties.IsSavable
			{
				get
				{
					IsSavable.RecordGet();
					if (IsSavable.OnGet is { } onGet) return onGet();
					if (IsSavable._source is { } src) return src.IsSavable;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IEntityMetaProperties", "IsSavable");
					return IsSavable.Value;
				}
			}

			bool global::Neatoo.RemoteFactory.IFactorySaveMeta.IsDeleted
			{
				get
				{
					IsDeleted.RecordGet();
					if (IsDeleted.OnGet is { } onGet) return onGet();
					if (IsDeleted._source is { } src) return src.IsDeleted;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IFactorySaveMeta", "IsDeleted");
					return IsDeleted.Value;
				}
			}

			bool global::Neatoo.RemoteFactory.IFactorySaveMeta.IsNew
			{
				get
				{
					IsNew.RecordGet();
					if (IsNew.OnGet is { } onGet) return onGet();
					if (IsNew._source is { } src) return src.IsNew;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IFactorySaveMeta", "IsNew");
					return IsNew.Value;
				}
			}

			event global::System.Collections.Specialized.NotifyCollectionChangedEventHandler? global::System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged
			{
				add => CollectionChangedInterceptor.RecordAdd(value);
				remove => CollectionChangedInterceptor.RecordRemove(value);
			}

			event global::System.ComponentModel.PropertyChangedEventHandler? global::System.ComponentModel.INotifyPropertyChanged.PropertyChanged
			{
				add => PropertyChangedInterceptor.RecordAdd(value);
				remove => PropertyChangedInterceptor.RecordRemove(value);
			}

			event global::Neatoo.NeatooPropertyChanged? global::Neatoo.INotifyNeatooPropertyChanged.NeatooPropertyChanged
			{
				add => NeatooPropertyChangedInterceptor.RecordAdd(value);
				remove => NeatooPropertyChangedInterceptor.RecordRemove(value);
			}

			/// <summary>The global::DomainModel.IPersonPhoneList instance. Use for passing to code expecting the interface.</summary>
			public global::DomainModel.IPersonPhoneList Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IPersonPhoneList(bool strict = false)
			{
				Strict = strict;
			}

			/// <summary>Sets the source object for global::DomainModel.IPersonPhoneList delegation.</summary>
			public void Source(global::DomainModel.IPersonPhoneList? source)
			{
				Parent._source = source;
				Count._source = source;
				IsReadOnly._source = source;
				IsBusy._source = source;
				IsValid._source = source;
				IsSelfValid._source = source;
				PropertyMessages._source = source;
				IsChild._source = source;
				IsModified._source = source;
				IsSelfModified._source = source;
				IsMarkedModified._source = source;
				IsSavable._source = source;
				IsDeleted._source = source;
				IsNew._source = source;
				Indexer._source = source;
				AddPhoneNumber._source = source;
				RemovePhoneNumber._source = source;
				RemoveAt._source = source;
				IndexOf._source = source;
				Insert._source = source;
				Add._source = source;
				Clear._source = source;
				Contains._source = source;
				CopyTo._source = source;
				Remove._source = source;
				GetEnumerator._source = source;
				WaitForTasks._source = source;
				RunRules._source = source;
				ClearAllMessages._source = source;
				ClearSelfMessages._source = source;
			}

			/// <summary>Sets the source object for global::Neatoo.IEntityListBase<global::DomainModel.IPersonPhone> delegation.</summary>
			public void Source(global::Neatoo.IEntityListBase<global::DomainModel.IPersonPhone>? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = source;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.IValidateListBase<global::DomainModel.IPersonPhone> delegation.</summary>
			public void Source(global::Neatoo.IValidateListBase<global::DomainModel.IPersonPhone>? source)
			{
				Parent._source = source;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone> delegation.</summary>
			public void Source(global::System.Collections.Generic.IList<global::DomainModel.IPersonPhone>? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = source;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = source;
				Insert._source = source;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone> delegation.</summary>
			public void Source(global::System.Collections.Generic.ICollection<global::DomainModel.IPersonPhone>? source)
			{
				Parent._source = null;
				Count._source = source;
				IsReadOnly._source = source;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = source;
				Clear._source = source;
				Contains._source = source;
				CopyTo._source = source;
				Remove._source = source;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.Collections.Generic.IEnumerable<global::DomainModel.IPersonPhone> delegation.</summary>
			public void Source(global::System.Collections.Generic.IEnumerable<global::DomainModel.IPersonPhone>? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = source;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.Collections.IEnumerable delegation.</summary>
			public void Source(global::System.Collections.IEnumerable? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.INeatooObject delegation.</summary>
			public void Source(global::Neatoo.INeatooObject? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.Collections.Specialized.INotifyCollectionChanged delegation.</summary>
			public void Source(global::System.Collections.Specialized.INotifyCollectionChanged? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.ComponentModel.INotifyPropertyChanged delegation.</summary>
			public void Source(global::System.ComponentModel.INotifyPropertyChanged? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.INotifyNeatooPropertyChanged delegation.</summary>
			public void Source(global::Neatoo.INotifyNeatooPropertyChanged? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.IValidateMetaProperties delegation.</summary>
			public void Source(global::Neatoo.IValidateMetaProperties? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = source;
				IsValid._source = source;
				IsSelfValid._source = source;
				PropertyMessages._source = source;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = source;
				RunRules._source = source;
				ClearAllMessages._source = source;
				ClearSelfMessages._source = source;
			}

			/// <summary>Sets the source object for global::Neatoo.IEntityMetaProperties delegation.</summary>
			public void Source(global::Neatoo.IEntityMetaProperties? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = source;
				IsModified._source = source;
				IsSelfModified._source = source;
				IsMarkedModified._source = source;
				IsSavable._source = source;
				IsDeleted._source = null;
				IsNew._source = null;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.RemoteFactory.IFactorySaveMeta delegation.</summary>
			public void Source(global::Neatoo.RemoteFactory.IFactorySaveMeta? source)
			{
				Parent._source = null;
				Count._source = null;
				IsReadOnly._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				IsChild._source = null;
				IsModified._source = null;
				IsSelfModified._source = null;
				IsMarkedModified._source = null;
				IsSavable._source = null;
				IsDeleted._source = source;
				IsNew._source = source;
				Indexer._source = null;
				AddPhoneNumber._source = null;
				RemovePhoneNumber._source = null;
				RemoveAt._source = null;
				IndexOf._source = null;
				Insert._source = null;
				Add._source = null;
				Clear._source = null;
				Contains._source = null;
				CopyTo._source = null;
				Remove._source = null;
				GetEnumerator._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>
			public void Verify()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Parent.CheckVerification() is { } parentFailure) failures.Add(parentFailure);
				if (Count.CheckVerification() is { } countFailure) failures.Add(countFailure);
				if (IsReadOnly.CheckVerification() is { } isreadonlyFailure) failures.Add(isreadonlyFailure);
				if (IsBusy.CheckVerification() is { } isbusyFailure) failures.Add(isbusyFailure);
				if (IsValid.CheckVerification() is { } isvalidFailure) failures.Add(isvalidFailure);
				if (IsSelfValid.CheckVerification() is { } isselfvalidFailure) failures.Add(isselfvalidFailure);
				if (PropertyMessages.CheckVerification() is { } propertymessagesFailure) failures.Add(propertymessagesFailure);
				if (IsChild.CheckVerification() is { } ischildFailure) failures.Add(ischildFailure);
				if (IsModified.CheckVerification() is { } ismodifiedFailure) failures.Add(ismodifiedFailure);
				if (IsSelfModified.CheckVerification() is { } isselfmodifiedFailure) failures.Add(isselfmodifiedFailure);
				if (IsMarkedModified.CheckVerification() is { } ismarkedmodifiedFailure) failures.Add(ismarkedmodifiedFailure);
				if (IsSavable.CheckVerification() is { } issavableFailure) failures.Add(issavableFailure);
				if (IsDeleted.CheckVerification() is { } isdeletedFailure) failures.Add(isdeletedFailure);
				if (IsNew.CheckVerification() is { } isnewFailure) failures.Add(isnewFailure);
				if (Indexer.CheckVerification() is { } indexerFailure) failures.Add(indexerFailure);
				if (AddPhoneNumber.CheckVerification() is { } addphonenumberFailure) failures.Add(addphonenumberFailure);
				if (RemovePhoneNumber.CheckVerification() is { } removephonenumberFailure) failures.Add(removephonenumberFailure);
				if (RemoveAt.CheckVerification() is { } removeatFailure) failures.Add(removeatFailure);
				if (IndexOf.CheckVerification() is { } indexofFailure) failures.Add(indexofFailure);
				if (Insert.CheckVerification() is { } insertFailure) failures.Add(insertFailure);
				if (Add.CheckVerification() is { } addFailure) failures.Add(addFailure);
				if (Clear.CheckVerification() is { } clearFailure) failures.Add(clearFailure);
				if (Contains.CheckVerification() is { } containsFailure) failures.Add(containsFailure);
				if (CopyTo.CheckVerification() is { } copytoFailure) failures.Add(copytoFailure);
				if (Remove.CheckVerification() is { } removeFailure) failures.Add(removeFailure);
				if (GetEnumerator.CheckVerification() is { } getenumeratorFailure) failures.Add(getenumeratorFailure);
				if (WaitForTasks.CheckVerification() is { } waitfortasksFailure) failures.Add(waitfortasksFailure);
				if (RunRules.CheckVerification() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (ClearAllMessages.CheckVerification() is { } clearallmessagesFailure) failures.Add(clearallmessagesFailure);
				if (ClearSelfMessages.CheckVerification() is { } clearselfmessagesFailure) failures.Add(clearselfmessagesFailure);
				if (CollectionChangedInterceptor.CheckVerification() is { } collectionchangedinterceptorFailure) failures.Add(collectionchangedinterceptorFailure);
				if (PropertyChangedInterceptor.CheckVerification() is { } propertychangedinterceptorFailure) failures.Add(propertychangedinterceptorFailure);
				if (NeatooPropertyChangedInterceptor.CheckVerification() is { } neatoopropertychangedinterceptorFailure) failures.Add(neatoopropertychangedinterceptorFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

			/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>
			public void VerifyAll()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Parent.CheckVerificationAll() is { } parentFailure) failures.Add(parentFailure);
				if (Count.CheckVerificationAll() is { } countFailure) failures.Add(countFailure);
				if (IsReadOnly.CheckVerificationAll() is { } isreadonlyFailure) failures.Add(isreadonlyFailure);
				if (IsBusy.CheckVerificationAll() is { } isbusyFailure) failures.Add(isbusyFailure);
				if (IsValid.CheckVerificationAll() is { } isvalidFailure) failures.Add(isvalidFailure);
				if (IsSelfValid.CheckVerificationAll() is { } isselfvalidFailure) failures.Add(isselfvalidFailure);
				if (PropertyMessages.CheckVerificationAll() is { } propertymessagesFailure) failures.Add(propertymessagesFailure);
				if (IsChild.CheckVerificationAll() is { } ischildFailure) failures.Add(ischildFailure);
				if (IsModified.CheckVerificationAll() is { } ismodifiedFailure) failures.Add(ismodifiedFailure);
				if (IsSelfModified.CheckVerificationAll() is { } isselfmodifiedFailure) failures.Add(isselfmodifiedFailure);
				if (IsMarkedModified.CheckVerificationAll() is { } ismarkedmodifiedFailure) failures.Add(ismarkedmodifiedFailure);
				if (IsSavable.CheckVerificationAll() is { } issavableFailure) failures.Add(issavableFailure);
				if (IsDeleted.CheckVerificationAll() is { } isdeletedFailure) failures.Add(isdeletedFailure);
				if (IsNew.CheckVerificationAll() is { } isnewFailure) failures.Add(isnewFailure);
				if (Indexer.CheckVerificationAll() is { } indexerFailure) failures.Add(indexerFailure);
				if (AddPhoneNumber.CheckVerificationAll() is { } addphonenumberFailure) failures.Add(addphonenumberFailure);
				if (RemovePhoneNumber.CheckVerificationAll() is { } removephonenumberFailure) failures.Add(removephonenumberFailure);
				if (RemoveAt.CheckVerificationAll() is { } removeatFailure) failures.Add(removeatFailure);
				if (IndexOf.CheckVerificationAll() is { } indexofFailure) failures.Add(indexofFailure);
				if (Insert.CheckVerificationAll() is { } insertFailure) failures.Add(insertFailure);
				if (Add.CheckVerificationAll() is { } addFailure) failures.Add(addFailure);
				if (Clear.CheckVerificationAll() is { } clearFailure) failures.Add(clearFailure);
				if (Contains.CheckVerificationAll() is { } containsFailure) failures.Add(containsFailure);
				if (CopyTo.CheckVerificationAll() is { } copytoFailure) failures.Add(copytoFailure);
				if (Remove.CheckVerificationAll() is { } removeFailure) failures.Add(removeFailure);
				if (GetEnumerator.CheckVerificationAll() is { } getenumeratorFailure) failures.Add(getenumeratorFailure);
				if (WaitForTasks.CheckVerificationAll() is { } waitfortasksFailure) failures.Add(waitfortasksFailure);
				if (RunRules.CheckVerificationAll() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (ClearAllMessages.CheckVerificationAll() is { } clearallmessagesFailure) failures.Add(clearallmessagesFailure);
				if (ClearSelfMessages.CheckVerificationAll() is { } clearselfmessagesFailure) failures.Add(clearselfmessagesFailure);
				if (CollectionChangedInterceptor.CheckVerificationAll() is { } collectionchangedinterceptorFailure) failures.Add(collectionchangedinterceptorFailure);
				if (PropertyChangedInterceptor.CheckVerificationAll() is { } propertychangedinterceptorFailure) failures.Add(propertychangedinterceptorFailure);
				if (NeatooPropertyChangedInterceptor.CheckVerificationAll() is { } neatoopropertychangedinterceptorFailure) failures.Add(neatoopropertychangedinterceptorFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

		}

	}
}
