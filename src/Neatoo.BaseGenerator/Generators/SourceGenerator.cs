using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Neatoo.BaseGenerator.Models;

namespace Neatoo.BaseGenerator.Generators;

/// <summary>
/// Main source code generator that orchestrates all code generation.
/// Called during the execute phase of the incremental generator.
/// Uses ONLY the extracted NeatooClassInfo data, NO SemanticModel access.
/// </summary>
internal static class SourceGenerator
{
    /// <summary>
    /// Generate complete source file for the class.
    /// </summary>
    public static string GenerateSource(NeatooClassInfo classInfo)
    {
        var sb = new StringBuilder();

        // Nullable context
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using directives
        foreach (var usingDirective in classInfo.UsingDirectives)
        {
            sb.AppendLine(usingDirective);
        }

        // Header comment
        sb.AppendLine("/*");
        sb.AppendLine("DO NOT MODIFY");
        if (classInfo.IsMinimalGeneration)
        {
            sb.AppendLine("Generated by Neatoo.BaseGenerator (minimal)");
        }
        else
        {
            sb.AppendLine("Generated by Neatoo.BaseGenerator");
        }
        sb.AppendLine("*/");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {classInfo.Namespace}");
        sb.AppendLine("{");

        // Interface (if needed, only for full generation)
        if (classInfo.HasPartialInterface && !classInfo.IsMinimalGeneration)
        {
            PropertyGenerator.GenerateInterfaceDeclaration(sb, classInfo);
            sb.AppendLine();
        }

        // Class declaration
        sb.AppendLine($"{classInfo.ClassDeclarationText} {{");

        // Property backing fields
        PropertyGenerator.GenerateBackingFields(sb, classInfo.Properties);

        // Property implementations
        PropertyGenerator.GeneratePropertyImplementations(sb, classInfo.Properties);

        // Mapper methods (full generation only)
        if (!classInfo.IsMinimalGeneration && classInfo.MapperMethods.Count > 0)
        {
            MapperGenerator.GenerateMapperMethods(sb, classInfo.MapperMethods);
        }

        // GetRuleId (full generation only)
        if (!classInfo.IsMinimalGeneration && !classInfo.RuleExpressions.SortedExpressions.IsDefaultOrEmpty)
        {
            RuleIdGenerator.GenerateGetRuleIdMethod(sb, classInfo.RuleExpressions);
        }

        // InitializePropertyBackingFields
        InitializerGenerator.GenerateInitializeMethod(sb, classInfo);

        // Close class and namespace
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("}");

        // Normalize whitespace using Roslyn
        var source = sb.ToString();

        // Handle replacements for edge cases
        source = source.Replace("[, ", "[");
        source = source.Replace("(, ", "(");
        source = source.Replace(", )", ")");

        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        var root = syntaxTree.GetRoot();
        var normalized = root.NormalizeWhitespace();
        return normalized.ToFullString();
    }
}
