// <auto-generated/>
#nullable enable

using System.Linq;

namespace Neatoo.UnitTest.Unit.Rules;

partial class ActionFluentRuleTests
{
	/// <summary>Contains stub implementations for inline stub pattern.</summary>
	public static class Stubs
	{
		private interface IGenericMethodCallTracker { int CallCount { get; } }
		private interface IResettable { void Reset(); }

		/// <summary>Interceptor for IRuleManager.Rules.</summary>
		public sealed class IRuleManager_RulesInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::System.Collections.Generic.IEnumerable<global::Neatoo.Rules.IRule>>? OnGet { get; set; }

			private global::System.Collections.Generic.IEnumerable<global::Neatoo.Rules.IRule> _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::System.Collections.Generic.IEnumerable<global::Neatoo.Rules.IRule> Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.Rules.IRuleManager? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IRuleManager_RulesInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IRuleManager_RulesInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Rules", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Rules (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Rules", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Rules", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Tracks and configures behavior for RunRules.</summary>
		public sealed class IRuleManager_RunRulesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.Rules.IRuleManager? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task(string propertyName, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task? _onCall_String_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_String_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Delegate for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RunRules", times, TotalCallCount));
			}

			/// <summary>Configures callback for RunRules(string, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(string, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Configures callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Invokes configured callback for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(bool strict, string propertyName, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task < _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_String_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((propertyName, token));
					_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(propertyName, token);
				}

				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((propertyName, token));
					return _onCall_String_Threading_CancellationToken_Threading_Tasks_Task(propertyName, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(propertyName, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Invokes configured callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(bool strict, global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task < _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((runRules, token));
					_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(runRules, token);
				}

				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((runRules, token));
					return _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(runRules, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(runRules, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task || _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0 || _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				if (_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)>
			{
				private readonly IRuleManager_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IRuleManager_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (string propertyName, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (string propertyName, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((string propertyName, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)>
			{
				private readonly IRuleManager_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IRuleManager_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IRuleManager_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IRuleManager_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IRuleManager_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IRuleManager_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for RunRule.</summary>
		public sealed class IRuleManager_RunRuleInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.Rules.IRuleManager? _source;

			/// <summary>Delegate for RunRule.</summary>
			public delegate global::System.Threading.Tasks.Task RunRuleDelegate(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token);

			private RunRuleDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(RunRuleDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private (global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)? _unconfiguredLastArgs;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)? LastCallArgs { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArgs; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RunRule", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)> OnCall(RunRuleDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<RunRuleDelegate> OnCallSequence(RunRuleDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(RunRuleDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Threading.Tasks.Task Invoke(bool strict, global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall((r, token));
					_sequenceIndex++;
					return callback(r, token);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall((r, token));
					return _onCall(r, token);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArgs = ((r, token));
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRule");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRule(r, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRule");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RunRule", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("RunRule", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)>
			{
				private readonly IRuleManager_RunRuleInterceptor _interceptor;

				public MethodTrackingImpl(IRuleManager_RunRuleInterceptor interceptor) => _interceptor = interceptor;

				private (global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<RunRuleDelegate>
			{
				private readonly IRuleManager_RunRuleInterceptor _interceptor;

				public MethodSequenceImpl(IRuleManager_RunRuleInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRuleDelegate> ThenCall(RunRuleDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRuleDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Interceptor for AddRule.</summary>
		public sealed class IRuleManager_AddRuleInterceptor
		{
			private readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> _typedHandlers = new();

			/// <summary>Gets the typed handler for the specified type argument(s).</summary>
			public AddRuleTypedHandler<T> Of<T>() where T : global::Neatoo.IValidateBase
			{
				var key = typeof(T);
				if (!_typedHandlers.TryGetValue(key, out var handler))
				{
					handler = new AddRuleTypedHandler<T>();
					_typedHandlers[key] = handler;
				}
				return (AddRuleTypedHandler<T>)handler;
			}

			private int TotalCallCount => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Sum(h => h.CallCount);

			/// <summary>All type argument(s) that were used in calls.</summary>
			public global::System.Collections.Generic.IReadOnlyList<global::System.Type> CalledTypeArguments => _typedHandlers.Where(kvp => ((IGenericMethodCallTracker)kvp.Value).CallCount > 0).Select(kvp => kvp.Key).ToList();

			/// <summary>Resets tracking state (call counts) but preserves configuration (OnCall callbacks).</summary>
			public void Reset()
			{
				foreach (var handler in _typedHandlers.Values.Cast<IResettable>())
					handler.Reset();
			}

			/// <summary>Verifies method was called at least once with any type argument. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("AddRule", times, TotalCallCount));
			}

			internal bool IsVerifiable => false; // Generic handlers are not individually verifiable
			internal bool IsConfigured => _typedHandlers.Count > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification() => null; // Generic methods not individually verifiable

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return TotalCallCount >= 1 ? null : new global::KnockOff.VerificationFailure("AddRule", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Typed handler for AddRule with specific type arguments.</summary>
			public sealed class AddRuleTypedHandler<T> : IGenericMethodCallTracker, IResettable, global::KnockOff.IMethodTracking where T : global::Neatoo.IValidateBase
			{
				/// <summary>Delegate for AddRule.</summary>
				public delegate void AddRuleDelegate(global::Neatoo.Rules.IRule<T> rule, string? sourceExpression);

				private AddRuleDelegate? _onCall;

				private int _callCount;
				int IGenericMethodCallTracker.CallCount => _callCount;

				/// <summary>The 'sourceExpression' argument from the most recent call.</summary>
				public string? LastCallArg { get; private set; }

				/// <summary>Sets the callback invoked when this method is called. Returns this handler for tracking.</summary>
				public global::KnockOff.IMethodTracking OnCall(AddRuleDelegate callback) { _onCall = callback; return this; }

				/// <summary>Gets the configured callback (internal use).</summary>
				internal AddRuleDelegate? Callback => _onCall;

				/// <summary>Records a method call.</summary>
				public void RecordCall(string? sourceExpression) { _callCount++; LastCallArg = sourceExpression; }

				/// <summary>Resets tracking state (_callCount, LastCallArg/LastCallArgs) but preserves configuration (OnCall).</summary>
				public void Reset() { _callCount = 0; LastCallArg = default; }

				/// <summary>Verifies call count is at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(_callCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, _callCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable() => this;

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times) => this;
			}
		}

		/// <summary>Interceptor for RunRuleGeneric.</summary>
		public sealed class IRuleManager_RunRuleGenericInterceptor
		{
			private readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> _typedHandlers = new();

			/// <summary>Gets the typed handler for the specified type argument(s).</summary>
			public RunRuleGenericTypedHandler<T> Of<T>() where T : global::Neatoo.Rules.IRule
			{
				var key = typeof(T);
				if (!_typedHandlers.TryGetValue(key, out var handler))
				{
					handler = new RunRuleGenericTypedHandler<T>();
					_typedHandlers[key] = handler;
				}
				return (RunRuleGenericTypedHandler<T>)handler;
			}

			private int TotalCallCount => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Sum(h => h.CallCount);

			/// <summary>All type argument(s) that were used in calls.</summary>
			public global::System.Collections.Generic.IReadOnlyList<global::System.Type> CalledTypeArguments => _typedHandlers.Where(kvp => ((IGenericMethodCallTracker)kvp.Value).CallCount > 0).Select(kvp => kvp.Key).ToList();

			/// <summary>Resets tracking state (call counts) but preserves configuration (OnCall callbacks).</summary>
			public void Reset()
			{
				foreach (var handler in _typedHandlers.Values.Cast<IResettable>())
					handler.Reset();
			}

			/// <summary>Verifies method was called at least once with any type argument. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RunRuleGeneric", times, TotalCallCount));
			}

			internal bool IsVerifiable => false; // Generic handlers are not individually verifiable
			internal bool IsConfigured => _typedHandlers.Count > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification() => null; // Generic methods not individually verifiable

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return TotalCallCount >= 1 ? null : new global::KnockOff.VerificationFailure("RunRuleGeneric", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Typed handler for RunRuleGeneric with specific type arguments.</summary>
			public sealed class RunRuleGenericTypedHandler<T> : IGenericMethodCallTracker, IResettable, global::KnockOff.IMethodTracking where T : global::Neatoo.Rules.IRule
			{
				/// <summary>Delegate for RunRuleGeneric.</summary>
				public delegate global::System.Threading.Tasks.Task RunRuleGenericDelegate(global::System.Threading.CancellationToken? token);

				private RunRuleGenericDelegate? _onCall;

				private int _callCount;
				int IGenericMethodCallTracker.CallCount => _callCount;

				/// <summary>The 'token' argument from the most recent call.</summary>
				public global::System.Threading.CancellationToken? LastCallArg { get; private set; }

				/// <summary>Sets the callback invoked when this method is called. Returns this handler for tracking.</summary>
				public global::KnockOff.IMethodTracking OnCall(RunRuleGenericDelegate callback) { _onCall = callback; return this; }

				/// <summary>Gets the configured callback (internal use).</summary>
				internal RunRuleGenericDelegate? Callback => _onCall;

				/// <summary>Records a method call.</summary>
				public void RecordCall(global::System.Threading.CancellationToken? token) { _callCount++; LastCallArg = token; }

				/// <summary>Resets tracking state (_callCount, LastCallArg/LastCallArgs) but preserves configuration (OnCall).</summary>
				public void Reset() { _callCount = 0; LastCallArg = default; }

				/// <summary>Verifies call count is at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(_callCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, _callCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable() => this;

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times) => this;
			}
		}

		/// <summary>Stub implementation of global::Neatoo.Rules.IRuleManager.</summary>
		public class IRuleManager : global::Neatoo.Rules.IRuleManager, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for Rules.</summary>
			public IRuleManager_RulesInterceptor Rules { get; } = new();

			/// <summary>Interceptor for RunRules.</summary>
			public IRuleManager_RunRulesInterceptor RunRules { get; } = new();

			/// <summary>Interceptor for AddRule.</summary>
			public IRuleManager_AddRuleInterceptor AddRule { get; } = new();

			/// <summary>Interceptor for RunRule (non-generic overloads).</summary>
			public IRuleManager_RunRuleInterceptor RunRule { get; } = new();

			/// <summary>Interceptor for RunRule (generic overloads, use .Of<T>()).</summary>
			public IRuleManager_RunRuleGenericInterceptor RunRuleGeneric { get; } = new();

			global::System.Threading.Tasks.Task global::Neatoo.Rules.IRuleManager.RunRules(string propertyName, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(Strict, propertyName, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.Rules.IRuleManager.RunRules(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(Strict, runRules, token);
			}

			void global::Neatoo.Rules.IRuleManager.AddRule<T>(global::Neatoo.Rules.IRule<T> rule, string? sourceExpression)
			{
				var typedHandler = AddRule.Of<T>();
				typedHandler.RecordCall(sourceExpression);
				if (typedHandler.Callback is { } onCallCallback)
				{ onCallCallback(rule, sourceExpression); return; }
				if (Strict) throw global::KnockOff.StubException.NotConfigured("IRuleManager", "AddRule");
			}

			global::System.Threading.Tasks.Task global::Neatoo.Rules.IRuleManager.RunRule(global::Neatoo.Rules.IRule r, global::System.Threading.CancellationToken? token)
			{
				return RunRule.Invoke(Strict, r, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.Rules.IRuleManager.RunRule<T>(global::System.Threading.CancellationToken? token)
			{
				var typedHandler = RunRuleGeneric.Of<T>();
				typedHandler.RecordCall(token);
				if (typedHandler.Callback is { } onCallCallback)
					return onCallCallback(token);
				if (Strict) throw global::KnockOff.StubException.NotConfigured("IRuleManager", "RunRule");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			global::System.Collections.Generic.IEnumerable<global::Neatoo.Rules.IRule> global::Neatoo.Rules.IRuleManager.Rules
			{
				get
				{
					Rules.RecordGet();
					if (Rules.OnGet is { } onGet) return onGet();
					if (Rules._source is { } src) return src.Rules;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IRuleManager", "Rules");
					return Rules.Value;
				}
			}

			/// <summary>The global::Neatoo.Rules.IRuleManager instance. Use for passing to code expecting the interface.</summary>
			public global::Neatoo.Rules.IRuleManager Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IRuleManager(bool strict = false)
			{
				Strict = strict;
			}

			/// <summary>Sets the source object for global::Neatoo.Rules.IRuleManager delegation.</summary>
			public void Source(global::Neatoo.Rules.IRuleManager? source)
			{
				Rules._source = source;
				RunRules._source = source;
				RunRule._source = source;
			}

			/// <summary>Gets a smart default value for a generic type at runtime.</summary>
			private static T SmartDefault<T>(string methodName)
			{
				var type = typeof(T);

				// Value types -> default(T)
				if (type.IsValueType)
					return default!;

				// Check for parameterless constructor
				var ctor = type.GetConstructor(
					System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,
					null, System.Type.EmptyTypes, null);

				if (ctor != null)
					return (T)ctor.Invoke(null);

				throw new global::System.InvalidOperationException(
					$"No implementation provided for {methodName}<{type.Name}>. " +
					$"Set the handler's OnCall.");
			}

			/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>
			public void Verify()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Rules.CheckVerification() is { } rulesFailure) failures.Add(rulesFailure);
				if (RunRules.CheckVerification() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (AddRule.CheckVerification() is { } addruleFailure) failures.Add(addruleFailure);
				if (RunRule.CheckVerification() is { } runruleFailure) failures.Add(runruleFailure);
				if (RunRuleGeneric.CheckVerification() is { } runrulegenericFailure) failures.Add(runrulegenericFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

			/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>
			public void VerifyAll()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Rules.CheckVerificationAll() is { } rulesFailure) failures.Add(rulesFailure);
				if (RunRules.CheckVerificationAll() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (AddRule.CheckVerificationAll() is { } addruleFailure) failures.Add(addruleFailure);
				if (RunRule.CheckVerificationAll() is { } runruleFailure) failures.Add(runruleFailure);
				if (RunRuleGeneric.CheckVerificationAll() is { } runrulegenericFailure) failures.Add(runrulegenericFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

		}

	}
}
