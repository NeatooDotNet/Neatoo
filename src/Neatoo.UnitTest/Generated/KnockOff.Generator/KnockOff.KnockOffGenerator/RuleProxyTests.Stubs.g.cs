// <auto-generated/>
#nullable enable

namespace Neatoo.UnitTest.Unit.Rules;

partial class RuleProxyTests
{
	/// <summary>Contains stub implementations for inline stub pattern.</summary>
	public static class Stubs
	{
		/// <summary>Interceptor for IValidateBase.Parent.</summary>
		public sealed class IValidateBase_ParentInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::Neatoo.IValidateBase?>? OnGet { get; set; }

			private global::Neatoo.IValidateBase? _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::Neatoo.IValidateBase? Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateBase? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_ParentInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_ParentInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Parent", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Parent (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Parent", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Parent", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.IsPaused.</summary>
		public sealed class IValidateBase_IsPausedInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateBase? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_IsPausedInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_IsPausedInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsPaused", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsPaused (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsPaused", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsPaused", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.IsBusy.</summary>
		public sealed class IValidateBase_IsBusyInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_IsBusyInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_IsBusyInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsBusy", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsBusy (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsBusy", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsBusy", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.IsValid.</summary>
		public sealed class IValidateBase_IsValidInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_IsValidInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_IsValidInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsValid", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsValid (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsValid", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsValid", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.IsSelfValid.</summary>
		public sealed class IValidateBase_IsSelfValidInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<bool>? OnGet { get; set; }

			private bool _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public bool Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_IsSelfValidInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_IsSelfValidInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfValid", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("IsSelfValid (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("IsSelfValid", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("IsSelfValid", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.PropertyMessages.</summary>
		public sealed class IValidateBase_PropertyMessagesInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _valueSet;

			private int _getCount;

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage>>? OnGet { get; set; }

			private global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> _value = default!;
			/// <summary>Value returned by getter when OnGet is not set. Setting this marks the property as configured.</summary>
			public global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> Value
			{
				get => _value;
				set { _value = value; _valueSet = true; }
			}

			/// <summary>Source object for delegation when OnGet is not set.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => _getCount++;

			/// <summary>Resets tracking state (counts, LastSetValue) but preserves configuration (OnGet, OnSet, Value) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; _source = null; }

			/// <summary>Marks this property for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_PropertyMessagesInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this property for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_PropertyMessagesInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the property was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PropertyMessages", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("PropertyMessages (get)", times, _getCount));
			}

			/// <summary>Whether this property was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this property has been configured (Value set or callbacks registered).</summary>
			internal bool IsConfigured => _valueSet || OnGet != null;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("PropertyMessages", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("PropertyMessages", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Interceptor for IValidateBase.Indexer.</summary>
		public sealed class IValidateBase_IndexerInterceptor
		{
			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;
			private bool _configured;

			private int _getCount;

			/// <summary>The last key used to access the getter.</summary>
			public string? LastGetKey { get; private set; }

			private global::System.Func<string, global::Neatoo.IValidateProperty>? _onGet;
			/// <summary>Callback for getter. Setting this marks the indexer as configured.</summary>
			public global::System.Func<string, global::Neatoo.IValidateProperty>? OnGet
			{
				get => _onGet;
				set { _onGet = value; if (value != null) _configured = true; }
			}

			/// <summary>Records a getter access.</summary>
			public void RecordGet(string propertyName) { _getCount++; LastGetKey = propertyName; }

			/// <summary>Backing storage for this indexer.</summary>
			public global::System.Collections.Generic.Dictionary<string, global::Neatoo.IValidateProperty> Backing { get; } = new();

			/// <summary>Source object for delegation when OnGet/OnSet is not set.</summary>
			internal global::Neatoo.IValidateBase? _source;

			/// <summary>Resets tracking state (counts, LastGetKey, LastSetEntry) but preserves configuration (OnGet, OnSet, Backing) and verifiable marking.</summary>
			public void Reset() { _getCount = 0; LastGetKey = default; _source = null; }

			/// <summary>Marks this indexer for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_IndexerInterceptor Verifiable() { _isVerifiable = true; _verifiableTimes = null; return this; }

			/// <summary>Marks this indexer for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_IndexerInterceptor Verifiable(global::KnockOff.Times times) { _isVerifiable = true; _verifiableTimes = times; return this; }

			/// <summary>Verifies the indexer was accessed at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies total access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _getCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Indexer", times, totalCount));
			}

			/// <summary>Verifies the getter was accessed at least once. Throws VerificationException if not.</summary>
			public void VerifyGet() => VerifyGet(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies getter access count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void VerifyGet(global::KnockOff.Times times)
			{
				if (!times.Validate(_getCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("Indexer (get)", times, _getCount));
			}

			/// <summary>Whether this indexer was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this indexer has been configured (callbacks registered).</summary>
			internal bool IsConfigured => _configured;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _getCount;
				return times.Validate(totalCount) ? null : new global::KnockOff.VerificationFailure("Indexer", times, totalCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				var totalCount = _getCount;
				return totalCount >= 1 ? null : new global::KnockOff.VerificationFailure("Indexer", global::KnockOff.Times.AtLeastOnce, totalCount);
			}
		}

		/// <summary>Tracks and configures behavior for GetProperty.</summary>
		public sealed class IValidateBase_GetPropertyInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateBase? _source;

			/// <summary>Delegate for GetProperty.</summary>
			public delegate global::Neatoo.IValidateProperty GetPropertyDelegate(string propertyName);

			private GetPropertyDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(GetPropertyDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private string? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public string? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("GetProperty", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<string> OnCall(GetPropertyDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<GetPropertyDelegate> OnCallSequence(GetPropertyDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(GetPropertyDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::Neatoo.IValidateProperty Invoke(bool strict, string propertyName)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(propertyName);
					_sequenceIndex++;
					return callback(propertyName);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(propertyName);
					return _onCall(propertyName);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = propertyName;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("GetProperty");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.GetProperty(propertyName);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "GetProperty");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("GetProperty", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("GetProperty", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<string>
			{
				private readonly IValidateBase_GetPropertyInterceptor _interceptor;

				public MethodTrackingImpl(IValidateBase_GetPropertyInterceptor interceptor) => _interceptor = interceptor;

				private string _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public string LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(string propertyName) { CallCount++; _lastArg = propertyName; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<string> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<string> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<GetPropertyDelegate>
			{
				private readonly IValidateBase_GetPropertyInterceptor _interceptor;

				public MethodSequenceImpl(IValidateBase_GetPropertyInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<GetPropertyDelegate> ThenCall(GetPropertyDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<GetPropertyDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for TryGetProperty.</summary>
		public sealed class IValidateBase_TryGetPropertyInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateBase? _source;

			/// <summary>Delegate for TryGetProperty.</summary>
			public delegate bool TryGetPropertyDelegate(string propertyName, out global::Neatoo.IValidateProperty validateProperty);

			private TryGetPropertyDelegate? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(TryGetPropertyDelegate Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private string? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public string? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("TryGetProperty", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<string> OnCall(TryGetPropertyDelegate callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<TryGetPropertyDelegate> OnCallSequence(TryGetPropertyDelegate callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(TryGetPropertyDelegate Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal bool Invoke(bool strict, string propertyName, out global::Neatoo.IValidateProperty validateProperty)
			{
				validateProperty = default!;
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(propertyName);
					_sequenceIndex++;
					return callback(propertyName, out validateProperty);
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(propertyName);
					return _onCall(propertyName, out validateProperty);
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = propertyName;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("TryGetProperty");
					return default!;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.TryGetProperty(propertyName, out validateProperty);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "TryGetProperty");
				return default!;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("TryGetProperty", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("TryGetProperty", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<string>
			{
				private readonly IValidateBase_TryGetPropertyInterceptor _interceptor;

				public MethodTrackingImpl(IValidateBase_TryGetPropertyInterceptor interceptor) => _interceptor = interceptor;

				private string _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public string LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(string propertyName) { CallCount++; _lastArg = propertyName; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<string> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<string> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<TryGetPropertyDelegate>
			{
				private readonly IValidateBase_TryGetPropertyInterceptor _interceptor;

				public MethodSequenceImpl(IValidateBase_TryGetPropertyInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<TryGetPropertyDelegate> ThenCall(TryGetPropertyDelegate callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<TryGetPropertyDelegate> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for AddChildTask.</summary>
		public sealed class IValidateBase_AddChildTaskInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateBase? _source;

			private global::System.Action<global::System.Threading.Tasks.Task>? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action<global::System.Threading.Tasks.Task> Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;
			private global::System.Threading.Tasks.Task? _unconfiguredLastArg;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public global::System.Threading.Tasks.Task? LastCallArg { get { if ((_onCallTracking?.CallCount ?? 0) > 0) return _onCallTracking!.LastArg; if (_sequence != null) for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("AddChildTask", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.Tasks.Task> OnCall(global::System.Action<global::System.Threading.Tasks.Task> callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<global::System.Threading.Tasks.Task>> OnCallSequence(global::System.Action<global::System.Threading.Tasks.Task> callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action<global::System.Threading.Tasks.Task> Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict, global::System.Threading.Tasks.Task task)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall(task);
					_sequenceIndex++;
					callback(task);
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall(task);
					_onCall(task);
					return;
				}

				_unconfiguredCallCount++;
				_unconfiguredLastArg = task;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("AddChildTask");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.AddChildTask(task); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "AddChildTask");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddChildTask", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("AddChildTask", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<global::System.Threading.Tasks.Task>
			{
				private readonly IValidateBase_AddChildTaskInterceptor _interceptor;

				public MethodTrackingImpl(IValidateBase_AddChildTaskInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.Tasks.Task _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.Tasks.Task LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.Tasks.Task task) { CallCount++; _lastArg = task; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.Tasks.Task> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.Tasks.Task> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<global::System.Threading.Tasks.Task>>
			{
				private readonly IValidateBase_AddChildTaskInterceptor _interceptor;

				public MethodSequenceImpl(IValidateBase_AddChildTaskInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::System.Threading.Tasks.Task>> ThenCall(global::System.Action<global::System.Threading.Tasks.Task> callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<global::System.Threading.Tasks.Task>> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for WaitForTasks.</summary>
		public sealed class IValidateBase_WaitForTasksInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for WaitForTasks().</summary>
			public delegate global::System.Threading.Tasks.Task WaitForTasksDelegate_NoParams_Threading_Tasks_Task();

			private WaitForTasksDelegate_NoParams_Threading_Tasks_Task? _onCall_NoParams_Threading_Tasks_Task;
			private MethodTrackingImpl_NoParams_Threading_Tasks_Task? _onCallTracking_NoParams_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(WaitForTasksDelegate_NoParams_Threading_Tasks_Task Callback, MethodTrackingImpl_NoParams_Threading_Tasks_Task Tracking)>? _sequence_NoParams_Threading_Tasks_Task;
			private int _sequenceIndex_NoParams_Threading_Tasks_Task;

			private bool _isVerifiable_NoParams_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_NoParams_Threading_Tasks_Task;

			/// <summary>Delegate for WaitForTasks(global::System.Threading.CancellationToken).</summary>
			public delegate global::System.Threading.Tasks.Task WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task(global::System.Threading.CancellationToken token);

			private WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task? _onCall_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("WaitForTasks", times, TotalCallCount));
			}

			/// <summary>Configures callback for WaitForTasks(). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
			{
				_sequence_NoParams_Threading_Tasks_Task = null;
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				_isVerifiable_NoParams_Threading_Tasks_Task = false;
				_verifiableTimes_NoParams_Threading_Tasks_Task = null;
				_onCall_NoParams_Threading_Tasks_Task = callback;
				_onCallTracking_NoParams_Threading_Tasks_Task = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(this);
				return _onCallTracking_NoParams_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for WaitForTasks(). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> OnCallSequence(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
			{
				_onCall_NoParams_Threading_Tasks_Task = null;
				_onCallTracking_NoParams_Threading_Tasks_Task = null;
				_isVerifiable_NoParams_Threading_Tasks_Task = false;
				_verifiableTimes_NoParams_Threading_Tasks_Task = null;
				_sequence_NoParams_Threading_Tasks_Task = new global::System.Collections.Generic.List<(WaitForTasksDelegate_NoParams_Threading_Tasks_Task Callback, MethodTrackingImpl_NoParams_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(this);
				_sequence_NoParams_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_NoParams_Threading_Tasks_Task(this);
			}

			/// <summary>Configures callback for WaitForTasks(global::System.Threading.CancellationToken). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> OnCall(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for WaitForTasks(global::System.Threading.CancellationToken). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Invokes configured callback for WaitForTasks().</summary>
			internal global::System.Threading.Tasks.Task Invoke_NoParams_Threading_Tasks_Task(bool strict)
			{
				if (_sequence_NoParams_Threading_Tasks_Task != null && _sequenceIndex_NoParams_Threading_Tasks_Task < _sequence_NoParams_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_NoParams_Threading_Tasks_Task[_sequenceIndex_NoParams_Threading_Tasks_Task];
					tracking.RecordCall();
					_sequenceIndex_NoParams_Threading_Tasks_Task++;
					return callback();
				}

				if (_onCall_NoParams_Threading_Tasks_Task != null && _onCallTracking_NoParams_Threading_Tasks_Task != null)
				{
					_onCallTracking_NoParams_Threading_Tasks_Task.RecordCall();
					return _onCall_NoParams_Threading_Tasks_Task();
				}

				_unconfiguredCallCount++;
				if (_sequence_NoParams_Threading_Tasks_Task != null && _sequenceIndex_NoParams_Threading_Tasks_Task >= _sequence_NoParams_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("WaitForTasks");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.WaitForTasks();
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "WaitForTasks");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Invokes configured callback for WaitForTasks(global::System.Threading.CancellationToken).</summary>
			internal global::System.Threading.Tasks.Task Invoke_Threading_CancellationToken_Threading_Tasks_Task(bool strict, global::System.Threading.CancellationToken token)
			{
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task < _sequence_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall(token);
					_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(token);
				}

				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task.RecordCall(token);
					return _onCall_Threading_CancellationToken_Threading_Tasks_Task(token);
				}

				_unconfiguredCallCount++;
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("WaitForTasks");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.WaitForTasks(token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "WaitForTasks");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_NoParams_Threading_Tasks_Task?.Reset();
				if (_sequence_NoParams_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_NoParams_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_NoParams_Threading_Tasks_Task = 0;
				_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_NoParams_Threading_Tasks_Task || _isVerifiable_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_NoParams_Threading_Tasks_Task != null || (_sequence_NoParams_Threading_Tasks_Task?.Count ?? 0) > 0 || _onCall_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_NoParams_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_NoParams_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", times, count);
				}
				if (_isVerifiable_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_NoParams_Threading_Tasks_Task != null || (_sequence_NoParams_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_NoParams_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_NoParams_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("WaitForTasks", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_NoParams_Threading_Tasks_Task : global::KnockOff.IMethodTracking
			{
				private readonly IValidateBase_WaitForTasksInterceptor _interceptor;

				public MethodTrackingImpl_NoParams_Threading_Tasks_Task(IValidateBase_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = times;
					return this;
				}
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken>
			{
				private readonly IValidateBase_WaitForTasksInterceptor _interceptor;

				public MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private global::System.Threading.CancellationToken _lastArg = default!;

				internal int CallCount { get; private set; }

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public global::System.Threading.CancellationToken LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(global::System.Threading.CancellationToken token) { CallCount++; _lastArg = token; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking<global::System.Threading.CancellationToken> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_NoParams_Threading_Tasks_Task : global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task>
			{
				private readonly IValidateBase_WaitForTasksInterceptor _interceptor;

				public MethodSequenceImpl_NoParams_Threading_Tasks_Task(IValidateBase_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_NoParams_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_NoParams_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> ThenCall(WaitForTasksDelegate_NoParams_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_NoParams_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_NoParams_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_NoParams_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_NoParams_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_NoParams_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_NoParams_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_NoParams_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_NoParams_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IValidateBase_WaitForTasksInterceptor _interceptor;

				public MethodSequenceImpl_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_WaitForTasksInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<WaitForTasksDelegate_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for RunRules.</summary>
		public sealed class IValidateBase_RunRulesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private int _unconfiguredCallCount;

			/// <summary>Delegate for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task(string propertyName, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task? _onCall_String_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_String_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Delegate for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			public delegate global::System.Threading.Tasks.Task RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token);

			private RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task? _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>? _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private int _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private bool _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			private global::KnockOff.Times? _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			private int TotalCallCount => _unconfiguredCallCount + (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0) + (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);

			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("RunRules", times, TotalCallCount));
			}

			/// <summary>Configures callback for RunRules(string, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(string, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Configures callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> OnCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = callback;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				return _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
			}

			/// <summary>Starts a callback sequence for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?). Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> OnCallSequence(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
			{
				_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = false;
				_verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = new global::System.Collections.Generic.List<(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Callback, MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task Tracking)>();
				var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
				_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Add((callback, tracking));
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
				return new MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(this);
			}

			/// <summary>Invokes configured callback for RunRules(string, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(bool strict, string propertyName, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task < _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_String_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((propertyName, token));
					_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(propertyName, token);
				}

				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((propertyName, token));
					return _onCall_String_Threading_CancellationToken_Threading_Tasks_Task(propertyName, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(propertyName, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Invokes configured callback for RunRules(global::Neatoo.RunRulesFlag, global::System.Threading.CancellationToken?).</summary>
			internal global::System.Threading.Tasks.Task Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(bool strict, global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task < _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					var (callback, tracking) = _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task[_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task];
					tracking.RecordCall((runRules, token));
					_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task++;
					return callback(runRules, token);
				}

				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.RecordCall((runRules, token));
					return _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(runRules, token);
				}

				_unconfiguredCallCount++;
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null && _sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task >= _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("RunRules");
					return global::System.Threading.Tasks.Task.CompletedTask;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) return src.RunRules(runRules, token);
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "RunRules");
				return global::System.Threading.Tasks.Task.CompletedTask;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task = 0;
				_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Reset();
				if (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null)
				{
					foreach (var (_, tracking) in _sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
						tracking.Reset();
				}
				_sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = 0;
			}

			/// <summary>Whether any overload was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task || _isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;

			/// <summary>Whether any overload has been configured.</summary>
			internal bool IsConfigured => _onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0 || _onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - checks all verifiable overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (_isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				if (_isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
				{
					var times = _verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task ?? global::KnockOff.Times.AtLeastOnce;
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!times.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", times, count);
				}
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks all configured overloads.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (_onCall_String_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_String_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_String_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				if (_onCall_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task != null || (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Count ?? 0) > 0)
				{
					var count = (_onCallTracking_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.CallCount ?? 0) + (_sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task?.Sum(s => s.Tracking.CallCount) ?? 0);
					if (!global::KnockOff.Times.AtLeastOnce.Validate(count)) return new global::KnockOff.VerificationFailure("RunRules", global::KnockOff.Times.AtLeastOnce, count);
				}
				return null;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)>
			{
				private readonly IValidateBase_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (string propertyName, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (string propertyName, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((string propertyName, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(string propertyName, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)>
			{
				private readonly IValidateBase_RunRulesInterceptor _interceptor;

				public MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) _lastArgs;

				internal int CallCount { get; private set; }

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTrackingArgs<(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)> Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = times;
					return this;
				}

				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable() => Verifiable();
				global::KnockOff.IMethodTracking global::KnockOff.IMethodTracking.Verifiable(global::KnockOff.Times times) => Verifiable(times);
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IValidateBase_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_String_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_String_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_String_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_String_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_String_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_String_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_String_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task : global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task>
			{
				private readonly IValidateBase_RunRulesInterceptor _interceptor;

				public MethodSequenceImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(IValidateBase_RunRulesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> ThenCall(RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task callback)
				{
					var tracking = new MethodTrackingImpl_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(_interceptor);
					_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task == null) return;
					var sequenceLength = _interceptor._sequence_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task.Count;
					var completedCount = _interceptor._sequenceIndex_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<RunRulesDelegate_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task> Verifiable()
				{
					_interceptor._isVerifiable_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = true;
					_interceptor._verifiableTimes_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for ClearAllMessages.</summary>
		public sealed class IValidateBase_ClearAllMessagesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private global::System.Action? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("ClearAllMessages", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action> OnCallSequence(global::System.Action callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					callback();
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					_onCall();
					return;
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("ClearAllMessages");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.ClearAllMessages(); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "ClearAllMessages");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearAllMessages", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearAllMessages", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IValidateBase_ClearAllMessagesInterceptor _interceptor;

				public MethodTrackingImpl(IValidateBase_ClearAllMessagesInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action>
			{
				private readonly IValidateBase_ClearAllMessagesInterceptor _interceptor;

				public MethodSequenceImpl(IValidateBase_ClearAllMessagesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> ThenCall(global::System.Action callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Tracks and configures behavior for ClearSelfMessages.</summary>
		public sealed class IValidateBase_ClearSelfMessagesInterceptor
		{
			/// <summary>Source object to delegate to when no OnCall is configured.</summary>
			internal global::Neatoo.IValidateMetaProperties? _source;

			private global::System.Action? _onCall;
			private MethodTrackingImpl? _onCallTracking;

			private global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>? _sequence;
			private int _sequenceIndex;

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			private int _unconfiguredCallCount;

			private int TotalCallCount { get { var sum = _unconfiguredCallCount + (_onCallTracking?.CallCount ?? 0); if (_sequence != null) foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }


			/// <summary>Verifies method was called at least once. Throws VerificationException if not.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				if (!times.Validate(TotalCallCount))
					throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("ClearSelfMessages", times, TotalCallCount));
			}

			/// <summary>Configures callback that repeats indefinitely. Returns tracking interface for LastArg access.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action callback)
			{
				_sequence = null;
				_sequenceIndex = 0;
				_isVerifiable = false;
				_verifiableTimes = null;
				_onCall = callback;
				_onCallTracking = new MethodTrackingImpl(this);
				return _onCallTracking;
			}

			/// <summary>Starts a callback sequence. Returns sequence for ThenCall chaining. Each callback runs exactly once.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action> OnCallSequence(global::System.Action callback)
			{
				_onCall = null;
				_onCallTracking = null;
				_isVerifiable = false;
				_verifiableTimes = null;
				_sequence = new global::System.Collections.Generic.List<(global::System.Action Callback, MethodTrackingImpl Tracking)>();
				var tracking = new MethodTrackingImpl(this);
				_sequence.Add((callback, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(bool strict)
			{
				if (_sequence != null && _sequenceIndex < _sequence.Count)
				{
					var (callback, tracking) = _sequence[_sequenceIndex];
					tracking.RecordCall();
					_sequenceIndex++;
					callback();
					return;
				}

				if (_onCall != null && _onCallTracking != null)
				{
					_onCallTracking.RecordCall();
					_onCall();
					return;
				}

				_unconfiguredCallCount++;
				if (_sequence != null && _sequenceIndex >= _sequence.Count)
				{
					if (strict) throw global::KnockOff.StubException.SequenceExhausted("ClearSelfMessages");
					return;
				}

				#pragma warning disable CS8601, SYSLIB0050
				if (_source is { } src) { src.ClearSelfMessages(); return; }
				#pragma warning restore CS8601, SYSLIB0050
				if (strict) throw global::KnockOff.StubException.NotConfigured("", "ClearSelfMessages");
				return;
			}

			/// <summary>Resets tracking state but preserves configuration and verifiable marking.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_source = null;
				_onCallTracking?.Reset();
				if (_sequence != null)
				{
					foreach (var (_, tracking) in _sequence)
						tracking.Reset();
				}
				_sequenceIndex = 0;
			}

			/// <summary>Whether this interceptor was marked with Verifiable().</summary>
			internal bool IsVerifiable => _isVerifiable;

			/// <summary>Whether this interceptor has been configured (OnCall or OnCallSequence).</summary>
			internal bool IsConfigured => _onCall != null || (_sequence?.Count ?? 0) > 0;

			/// <summary>Checks verification for Stub.Verify() - only checks if marked verifiable.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				return times.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearSelfMessages", times, TotalCallCount);
			}

			/// <summary>Checks verification for Stub.VerifyAll() - checks if configured.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured) return null;
				return global::KnockOff.Times.AtLeastOnce.Validate(TotalCallCount) ? null : new global::KnockOff.VerificationFailure("ClearSelfMessages", global::KnockOff.Times.AtLeastOnce, TotalCallCount);
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{
				private readonly IValidateBase_ClearSelfMessagesInterceptor _interceptor;

				public MethodTrackingImpl(IValidateBase_ClearSelfMessagesInterceptor interceptor) => _interceptor = interceptor;


				internal int CallCount { get; private set; }

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;

				/// <summary>Verifies callback was invoked at least once. Throws VerificationException if not.</summary>
				public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

				/// <summary>Verifies call count satisfies the Times constraint. Throws VerificationException if not.</summary>
				public void Verify(global::KnockOff.Times times)
				{
					if (!times.Validate(CallCount))
						throw new global::KnockOff.VerificationException(new global::KnockOff.VerificationFailure("method", times, CallCount));
				}

				/// <summary>Marks for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodTracking Verifiable(global::KnockOff.Times times)
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = times;
					return this;
				}
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action>
			{
				private readonly IValidateBase_ClearSelfMessagesInterceptor _interceptor;

				public MethodSequenceImpl(IValidateBase_ClearSelfMessagesInterceptor interceptor) => _interceptor = interceptor;

				private int TotalCallCount
				{
					get
					{
						if (_interceptor._sequence == null) return 0;
						var total = 0;
						foreach (var (_, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Adds another callback to the sequence. Each callback runs exactly once.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> ThenCall(global::System.Action callback)
				{
					var tracking = new MethodTrackingImpl(_interceptor);
					_interceptor._sequence!.Add((callback, tracking));
					return this;
				}

				/// <summary>Verifies the entire sequence was executed (all callbacks invoked). Throws VerificationException if incomplete.</summary>
				public void Verify()
				{
					if (_interceptor._sequence == null) return;
					var sequenceLength = _interceptor._sequence.Count;
					var completedCount = _interceptor._sequenceIndex;
					if (completedCount < sequenceLength)
						throw new global::KnockOff.VerificationException(global::KnockOff.VerificationFailure.SequenceIncomplete("method", sequenceLength, completedCount));
				}

				/// <summary>Resets all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action> Verifiable()
				{
					_interceptor._isVerifiable = true;
					_interceptor._verifiableTimes = null;
					return this;
				}

				/// <summary>Marks this sequence for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
				global::KnockOff.IMethodSequence global::KnockOff.IMethodSequence.Verifiable() => Verifiable();
			}

		}

		/// <summary>Interceptor for IValidateBase.PropertyChanged event.</summary>
		public sealed class IValidateBase_PropertyChangedInterceptor
		{
			private int _addCount;
			private int _removeCount;

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.ComponentModel.PropertyChangedEventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.ComponentModel.PropertyChangedEventHandler? handler) { _addCount++; Handler = (global::System.ComponentModel.PropertyChangedEventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.ComponentModel.PropertyChangedEventHandler? handler) { _removeCount++; Handler = (global::System.ComponentModel.PropertyChangedEventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets tracking state (counts, Handler) but preserves verifiable marking.</summary>
			public void Reset() { _addCount = 0; _removeCount = 0; Handler = null; }

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			/// <summary>Verifies the event was subscribed to at least once.</summary>
			public void VerifyAdd() => VerifyAdd(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event subscription count matches the Times constraint.</summary>
			public void VerifyAdd(global::KnockOff.Times times)
			{
				if (!times.Validate(_addCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' add verification failed: expected {times}, but was called {_addCount} time(s).");
			}

			/// <summary>Verifies the event was unsubscribed at least once.</summary>
			public void VerifyRemove() => VerifyRemove(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event unsubscription count matches the Times constraint.</summary>
			public void VerifyRemove(global::KnockOff.Times times)
			{
				if (!times.Validate(_removeCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' remove verification failed: expected {times}, but was called {_removeCount} time(s).");
			}

			/// <summary>Verifies the event was accessed (add or remove) at least once.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the total event access count matches the Times constraint.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException($"Event 'PropertyChanged' verification failed: expected {times}, but was called {totalCount} time(s).");
			}

			/// <summary>Marks this event for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_PropertyChangedInterceptor Verifiable()
			{
				_isVerifiable = true;
				_verifiableTimes = global::KnockOff.Times.AtLeastOnce;
				return this;
			}

			/// <summary>Marks this event for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_PropertyChangedInterceptor Verifiable(global::KnockOff.Times times)
			{
				_isVerifiable = true;
				_verifiableTimes = times;
				return this;
			}

			internal bool IsVerifiable => _isVerifiable;
			internal bool IsConfigured => Handler != null;

			/// <summary>Checks verification for Stub.Verify() - only verifiable items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("PropertyChanged", times, totalCount);
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - all configured items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured && !_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("PropertyChanged", times, totalCount);
				return null;
			}
		}

		/// <summary>Interceptor for IValidateBase.NeatooPropertyChanged event.</summary>
		public sealed class IValidateBase_NeatooPropertyChangedInterceptor
		{
			private int _addCount;
			private int _removeCount;

			/// <summary>The backing delegate for raising the event.</summary>
			public global::Neatoo.NeatooPropertyChanged? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::Neatoo.NeatooPropertyChanged? handler) { _addCount++; Handler = (global::Neatoo.NeatooPropertyChanged?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::Neatoo.NeatooPropertyChanged? handler) { _removeCount++; Handler = (global::Neatoo.NeatooPropertyChanged?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets tracking state (counts, Handler) but preserves verifiable marking.</summary>
			public void Reset() { _addCount = 0; _removeCount = 0; Handler = null; }

			private bool _isVerifiable;
			private global::KnockOff.Times? _verifiableTimes;

			/// <summary>Verifies the event was subscribed to at least once.</summary>
			public void VerifyAdd() => VerifyAdd(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event subscription count matches the Times constraint.</summary>
			public void VerifyAdd(global::KnockOff.Times times)
			{
				if (!times.Validate(_addCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' add verification failed: expected {times}, but was called {_addCount} time(s).");
			}

			/// <summary>Verifies the event was unsubscribed at least once.</summary>
			public void VerifyRemove() => VerifyRemove(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the event unsubscription count matches the Times constraint.</summary>
			public void VerifyRemove(global::KnockOff.Times times)
			{
				if (!times.Validate(_removeCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' remove verification failed: expected {times}, but was called {_removeCount} time(s).");
			}

			/// <summary>Verifies the event was accessed (add or remove) at least once.</summary>
			public void Verify() => Verify(global::KnockOff.Times.AtLeastOnce);

			/// <summary>Verifies the total event access count matches the Times constraint.</summary>
			public void Verify(global::KnockOff.Times times)
			{
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					throw new global::KnockOff.VerificationException($"Event 'NeatooPropertyChanged' verification failed: expected {times}, but was called {totalCount} time(s).");
			}

			/// <summary>Marks this event for verification by Stub.Verify(). Returns this for fluent chaining.</summary>
			public IValidateBase_NeatooPropertyChangedInterceptor Verifiable()
			{
				_isVerifiable = true;
				_verifiableTimes = global::KnockOff.Times.AtLeastOnce;
				return this;
			}

			/// <summary>Marks this event for verification by Stub.Verify() with Times constraint. Returns this for fluent chaining.</summary>
			public IValidateBase_NeatooPropertyChangedInterceptor Verifiable(global::KnockOff.Times times)
			{
				_isVerifiable = true;
				_verifiableTimes = times;
				return this;
			}

			internal bool IsVerifiable => _isVerifiable;
			internal bool IsConfigured => Handler != null;

			/// <summary>Checks verification for Stub.Verify() - only verifiable items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerification()
			{
				if (!_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("NeatooPropertyChanged", times, totalCount);
				return null;
			}

			/// <summary>Checks verification for Stub.VerifyAll() - all configured items.</summary>
			internal global::KnockOff.VerificationFailure? CheckVerificationAll()
			{
				if (!IsConfigured && !_isVerifiable) return null;
				var times = _verifiableTimes ?? global::KnockOff.Times.AtLeastOnce;
				var totalCount = _addCount + _removeCount;
				if (!times.Validate(totalCount))
					return new global::KnockOff.VerificationFailure("NeatooPropertyChanged", times, totalCount);
				return null;
			}
		}

		/// <summary>Stub implementation of global::Neatoo.IValidateBase.</summary>
		public class IValidateBase : global::Neatoo.IValidateBase, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for Parent.</summary>
			public IValidateBase_ParentInterceptor Parent { get; } = new();

			/// <summary>Interceptor for IsPaused.</summary>
			public IValidateBase_IsPausedInterceptor IsPaused { get; } = new();

			/// <summary>Interceptor for IsBusy.</summary>
			public IValidateBase_IsBusyInterceptor IsBusy { get; } = new();

			/// <summary>Interceptor for IsValid.</summary>
			public IValidateBase_IsValidInterceptor IsValid { get; } = new();

			/// <summary>Interceptor for IsSelfValid.</summary>
			public IValidateBase_IsSelfValidInterceptor IsSelfValid { get; } = new();

			/// <summary>Interceptor for PropertyMessages.</summary>
			public IValidateBase_PropertyMessagesInterceptor PropertyMessages { get; } = new();

			/// <summary>Interceptor for indexer.</summary>
			public IValidateBase_IndexerInterceptor Indexer { get; } = new();

			/// <summary>Interceptor for GetProperty.</summary>
			public IValidateBase_GetPropertyInterceptor GetProperty { get; } = new();

			/// <summary>Interceptor for TryGetProperty.</summary>
			public IValidateBase_TryGetPropertyInterceptor TryGetProperty { get; } = new();

			/// <summary>Interceptor for AddChildTask.</summary>
			public IValidateBase_AddChildTaskInterceptor AddChildTask { get; } = new();

			/// <summary>Interceptor for WaitForTasks.</summary>
			public IValidateBase_WaitForTasksInterceptor WaitForTasks { get; } = new();

			/// <summary>Interceptor for RunRules.</summary>
			public IValidateBase_RunRulesInterceptor RunRules { get; } = new();

			/// <summary>Interceptor for ClearAllMessages.</summary>
			public IValidateBase_ClearAllMessagesInterceptor ClearAllMessages { get; } = new();

			/// <summary>Interceptor for ClearSelfMessages.</summary>
			public IValidateBase_ClearSelfMessagesInterceptor ClearSelfMessages { get; } = new();

			/// <summary>Interceptor for PropertyChanged event.</summary>
			public IValidateBase_PropertyChangedInterceptor PropertyChangedInterceptor { get; } = new();

			/// <summary>Interceptor for NeatooPropertyChanged event.</summary>
			public IValidateBase_NeatooPropertyChangedInterceptor NeatooPropertyChangedInterceptor { get; } = new();

			global::Neatoo.IValidateProperty global::Neatoo.IValidateBase.GetProperty(string propertyName)
			{
				return GetProperty.Invoke(Strict, propertyName);
			}

			bool global::Neatoo.IValidateBase.TryGetProperty(string propertyName, out global::Neatoo.IValidateProperty validateProperty)
			{
				return TryGetProperty.Invoke(Strict, propertyName, out validateProperty);
			}

			void global::Neatoo.IValidateBase.AddChildTask(global::System.Threading.Tasks.Task task)
			{
				AddChildTask.Invoke(Strict, task);
			}

			global::Neatoo.IValidateBase? global::Neatoo.IValidateBase.Parent
			{
				get
				{
					Parent.RecordGet();
					if (Parent.OnGet is { } onGet) return onGet();
					if (Parent._source is { } src) return src.Parent;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateBase", "Parent");
					return Parent.Value;
				}
			}

			bool global::Neatoo.IValidateBase.IsPaused
			{
				get
				{
					IsPaused.RecordGet();
					if (IsPaused.OnGet is { } onGet) return onGet();
					if (IsPaused._source is { } src) return src.IsPaused;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateBase", "IsPaused");
					return IsPaused.Value;
				}
			}

			global::Neatoo.IValidateProperty global::Neatoo.IValidateBase.this[string propertyName]
			{
				get
				{
					Indexer.RecordGet(propertyName);
					if (Indexer.OnGet is { } onGet) return onGet(propertyName);
					if (Indexer._source is { } src) return src[propertyName];
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateBase", "this[]");
					return Indexer.Backing.TryGetValue(propertyName, out var v) ? v : default!;
				}
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.WaitForTasks()
			{
				return WaitForTasks.Invoke_NoParams_Threading_Tasks_Task(Strict);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.WaitForTasks(global::System.Threading.CancellationToken token)
			{
				return WaitForTasks.Invoke_Threading_CancellationToken_Threading_Tasks_Task(Strict, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.RunRules(string propertyName, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_String_Threading_CancellationToken_Threading_Tasks_Task(Strict, propertyName, token);
			}

			global::System.Threading.Tasks.Task global::Neatoo.IValidateMetaProperties.RunRules(global::Neatoo.RunRulesFlag runRules, global::System.Threading.CancellationToken? token)
			{
				return RunRules.Invoke_Neatoo_RunRulesFlag_Threading_CancellationToken_Threading_Tasks_Task(Strict, runRules, token);
			}

			void global::Neatoo.IValidateMetaProperties.ClearAllMessages()
			{
				ClearAllMessages.Invoke(Strict);
			}

			void global::Neatoo.IValidateMetaProperties.ClearSelfMessages()
			{
				ClearSelfMessages.Invoke(Strict);
			}

			bool global::Neatoo.IValidateMetaProperties.IsBusy
			{
				get
				{
					IsBusy.RecordGet();
					if (IsBusy.OnGet is { } onGet) return onGet();
					if (IsBusy._source is { } src) return src.IsBusy;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsBusy");
					return IsBusy.Value;
				}
			}

			bool global::Neatoo.IValidateMetaProperties.IsValid
			{
				get
				{
					IsValid.RecordGet();
					if (IsValid.OnGet is { } onGet) return onGet();
					if (IsValid._source is { } src) return src.IsValid;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsValid");
					return IsValid.Value;
				}
			}

			bool global::Neatoo.IValidateMetaProperties.IsSelfValid
			{
				get
				{
					IsSelfValid.RecordGet();
					if (IsSelfValid.OnGet is { } onGet) return onGet();
					if (IsSelfValid._source is { } src) return src.IsSelfValid;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "IsSelfValid");
					return IsSelfValid.Value;
				}
			}

			global::System.Collections.Generic.IReadOnlyCollection<global::Neatoo.IPropertyMessage> global::Neatoo.IValidateMetaProperties.PropertyMessages
			{
				get
				{
					PropertyMessages.RecordGet();
					if (PropertyMessages.OnGet is { } onGet) return onGet();
					if (PropertyMessages._source is { } src) return src.PropertyMessages;
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IValidateMetaProperties", "PropertyMessages");
					return PropertyMessages.Value;
				}
			}

			event global::System.ComponentModel.PropertyChangedEventHandler? global::System.ComponentModel.INotifyPropertyChanged.PropertyChanged
			{
				add => PropertyChangedInterceptor.RecordAdd(value);
				remove => PropertyChangedInterceptor.RecordRemove(value);
			}

			event global::Neatoo.NeatooPropertyChanged? global::Neatoo.INotifyNeatooPropertyChanged.NeatooPropertyChanged
			{
				add => NeatooPropertyChangedInterceptor.RecordAdd(value);
				remove => NeatooPropertyChangedInterceptor.RecordRemove(value);
			}

			/// <summary>The global::Neatoo.IValidateBase instance. Use for passing to code expecting the interface.</summary>
			public global::Neatoo.IValidateBase Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IValidateBase(bool strict = false)
			{
				Strict = strict;
			}

			/// <summary>Sets the source object for global::Neatoo.IValidateBase delegation.</summary>
			public void Source(global::Neatoo.IValidateBase? source)
			{
				Parent._source = source;
				IsPaused._source = source;
				IsBusy._source = source;
				IsValid._source = source;
				IsSelfValid._source = source;
				PropertyMessages._source = source;
				Indexer._source = source;
				GetProperty._source = source;
				TryGetProperty._source = source;
				AddChildTask._source = source;
				WaitForTasks._source = source;
				RunRules._source = source;
				ClearAllMessages._source = source;
				ClearSelfMessages._source = source;
			}

			/// <summary>Sets the source object for global::Neatoo.INeatooObject delegation.</summary>
			public void Source(global::Neatoo.INeatooObject? source)
			{
				Parent._source = null;
				IsPaused._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				Indexer._source = null;
				GetProperty._source = null;
				TryGetProperty._source = null;
				AddChildTask._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::System.ComponentModel.INotifyPropertyChanged delegation.</summary>
			public void Source(global::System.ComponentModel.INotifyPropertyChanged? source)
			{
				Parent._source = null;
				IsPaused._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				Indexer._source = null;
				GetProperty._source = null;
				TryGetProperty._source = null;
				AddChildTask._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.INotifyNeatooPropertyChanged delegation.</summary>
			public void Source(global::Neatoo.INotifyNeatooPropertyChanged? source)
			{
				Parent._source = null;
				IsPaused._source = null;
				IsBusy._source = null;
				IsValid._source = null;
				IsSelfValid._source = null;
				PropertyMessages._source = null;
				Indexer._source = null;
				GetProperty._source = null;
				TryGetProperty._source = null;
				AddChildTask._source = null;
				WaitForTasks._source = null;
				RunRules._source = null;
				ClearAllMessages._source = null;
				ClearSelfMessages._source = null;
			}

			/// <summary>Sets the source object for global::Neatoo.IValidateMetaProperties delegation.</summary>
			public void Source(global::Neatoo.IValidateMetaProperties? source)
			{
				Parent._source = null;
				IsPaused._source = null;
				IsBusy._source = source;
				IsValid._source = source;
				IsSelfValid._source = source;
				PropertyMessages._source = source;
				Indexer._source = null;
				GetProperty._source = null;
				TryGetProperty._source = null;
				AddChildTask._source = null;
				WaitForTasks._source = source;
				RunRules._source = source;
				ClearAllMessages._source = source;
				ClearSelfMessages._source = source;
			}

			/// <summary>Verifies all members marked with .Verifiable() were invoked as expected. Throws VerificationException with all failures if any fail.</summary>
			public void Verify()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Parent.CheckVerification() is { } parentFailure) failures.Add(parentFailure);
				if (IsPaused.CheckVerification() is { } ispausedFailure) failures.Add(ispausedFailure);
				if (IsBusy.CheckVerification() is { } isbusyFailure) failures.Add(isbusyFailure);
				if (IsValid.CheckVerification() is { } isvalidFailure) failures.Add(isvalidFailure);
				if (IsSelfValid.CheckVerification() is { } isselfvalidFailure) failures.Add(isselfvalidFailure);
				if (PropertyMessages.CheckVerification() is { } propertymessagesFailure) failures.Add(propertymessagesFailure);
				if (Indexer.CheckVerification() is { } indexerFailure) failures.Add(indexerFailure);
				if (GetProperty.CheckVerification() is { } getpropertyFailure) failures.Add(getpropertyFailure);
				if (TryGetProperty.CheckVerification() is { } trygetpropertyFailure) failures.Add(trygetpropertyFailure);
				if (AddChildTask.CheckVerification() is { } addchildtaskFailure) failures.Add(addchildtaskFailure);
				if (WaitForTasks.CheckVerification() is { } waitfortasksFailure) failures.Add(waitfortasksFailure);
				if (RunRules.CheckVerification() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (ClearAllMessages.CheckVerification() is { } clearallmessagesFailure) failures.Add(clearallmessagesFailure);
				if (ClearSelfMessages.CheckVerification() is { } clearselfmessagesFailure) failures.Add(clearselfmessagesFailure);
				if (PropertyChangedInterceptor.CheckVerification() is { } propertychangedinterceptorFailure) failures.Add(propertychangedinterceptorFailure);
				if (NeatooPropertyChangedInterceptor.CheckVerification() is { } neatoopropertychangedinterceptorFailure) failures.Add(neatoopropertychangedinterceptorFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

			/// <summary>Verifies ALL configured members were invoked at least once. Throws VerificationException with all failures if any fail.</summary>
			public void VerifyAll()
			{
				var failures = new global::System.Collections.Generic.List<global::KnockOff.VerificationFailure>();

				if (Parent.CheckVerificationAll() is { } parentFailure) failures.Add(parentFailure);
				if (IsPaused.CheckVerificationAll() is { } ispausedFailure) failures.Add(ispausedFailure);
				if (IsBusy.CheckVerificationAll() is { } isbusyFailure) failures.Add(isbusyFailure);
				if (IsValid.CheckVerificationAll() is { } isvalidFailure) failures.Add(isvalidFailure);
				if (IsSelfValid.CheckVerificationAll() is { } isselfvalidFailure) failures.Add(isselfvalidFailure);
				if (PropertyMessages.CheckVerificationAll() is { } propertymessagesFailure) failures.Add(propertymessagesFailure);
				if (Indexer.CheckVerificationAll() is { } indexerFailure) failures.Add(indexerFailure);
				if (GetProperty.CheckVerificationAll() is { } getpropertyFailure) failures.Add(getpropertyFailure);
				if (TryGetProperty.CheckVerificationAll() is { } trygetpropertyFailure) failures.Add(trygetpropertyFailure);
				if (AddChildTask.CheckVerificationAll() is { } addchildtaskFailure) failures.Add(addchildtaskFailure);
				if (WaitForTasks.CheckVerificationAll() is { } waitfortasksFailure) failures.Add(waitfortasksFailure);
				if (RunRules.CheckVerificationAll() is { } runrulesFailure) failures.Add(runrulesFailure);
				if (ClearAllMessages.CheckVerificationAll() is { } clearallmessagesFailure) failures.Add(clearallmessagesFailure);
				if (ClearSelfMessages.CheckVerificationAll() is { } clearselfmessagesFailure) failures.Add(clearselfmessagesFailure);
				if (PropertyChangedInterceptor.CheckVerificationAll() is { } propertychangedinterceptorFailure) failures.Add(propertychangedinterceptorFailure);
				if (NeatooPropertyChangedInterceptor.CheckVerificationAll() is { } neatoopropertychangedinterceptorFailure) failures.Add(neatoopropertychangedinterceptorFailure);

				if (failures.Count > 0)
					throw new global::KnockOff.VerificationException(failures);
			}

		}

	}
}
